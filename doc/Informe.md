# Informe de Complementos de Compilaci√≥n
## Datos Generales
### Autores
- Yansaro Rodr√≠guez P√°ez
- Javier Alejandro Vald√©s Gonz√°lez
- Osmany P√©rez Rodr√≠guez

## Uso del compilador

## Requisitos para ejecutar el compilador
Para la ejecuci√≥n es necesario `Python >= 3.7` e instalar los requerimientos listados en *requirements.txt*. Esto se hace de manera f√°cil con la instrucci√≥n *pip install -r requirements.txt*. 

Para correr los tests se debe ejecutar `make test`. Para esto es necesario tener instalado `make`. Para ejecutar un archivo especifico se debe correr

```bash
python3 -m app $INPUT_FILE
```


## Pipeline
El programa cuenta con las siguientes etapas:

1. Lexer
2. Parsing
3. Recolecci√≥n de tipos
4. Construcci√≥n de tipos
5. Chequeo de tipos
7. Cool a CIL
8. CIL a MIPS

Cada parte del proceso ser√° discutida en detalle durante las siguientes secciones.

## Lexer

En el proceso de tokenizacion se uso la libreria SLY. En esta etapa se ignoran los comentarios de linea asi como los espacios en blanco. Para un mejor reporte de errores se dividio la etapa en varios estados: 

   - MAIN
   - block_comment
   - strings

En cada uno de estos estados se ejecuta un proceso de tokenizaci√≥n especializado. En el caso de los `block_comment` se maneja el caso de comentarios identados, y en string se manejan errores especificos como "No debe existir el caracter NULL" o "String no terminado".

### Gram√°tica de Cool

La gram√°tica utilizada es libre de contexto y de recursi√≥n extrema izquierda. Esto trae consigo que se presenten problemas de ambig√ºedad que son resueltos con la definici√≥n de reglas de precedencia en la implementaci√≥n del parser. (El el caso de SLY esto se resuelve ordenando los valores en la propiedad `precedence` de la clase `Parser`)

## Parsing
El parser se encarga de contruir el AST haciendo uso de los nodos definidos en (parser/ast). Los metodos del parser est√°n precedidos por un decorador que especifica que producci√≥n va a analizar el m√©todo, y este a su vez devuelve el resultado de parsear el nodo del AST correspondiente.



## An√°lisis Sem√°ntico

### Recolecci√≥n de tipos 

Para la recoleccion de tipos, al igual que para la mayoria de las etapas del proyecto se utiliza el patron `visitor`. Aqui se realiza un recorrido por el AST generado en la etapa de parsing, definiendo en el contexto los tipos encontrados y chequeando si ocurre alguno de los siguentes errores:

**Errores detectados**:
- Herencia c√≠clica
- Herencia no valida(no se deben redefinir  `Int`, `Bool` o `String`)



### Construcci√≥n de tipos

En esta etapa se verifica primeramente que el programa ofrecido sea valido, esto supone que tenga una clase principal `Main` con un metodo `main` sin argumentos. Tambien en el recorrido por el AST se incluyen en el contexto los metodos y atributos declarados en cada clase.

**Errores detectados**:

- Redefinici√≥n en un hijo sin conservar la cantidad de argumentos o tipo de retorno
- Redefinici√≥n de atributos
- Uso de tipos no definidos 
- No definici√≥n de la clase `Main` o su m√©todo `main`
- Incorrecta definici√≥n del m√©todo `main`

### Chequeo de tipos

El chequeo de tipos se dividi√≥ en dos etapas. Primeramente se realiza un recorrido sin profundidad, infiriendo los tipos declarados conforme su anotaci√≥n, llamando a este recorrido `ShahahallowInferrer` o con su nombre mas conocido `LadyGagaInferrer` (üòÇ). Luego se realiza otro recorrido con la informaci√≥n de los tipos inferidos en el recorrido anterior. 

En este ultimo recorrido `DeepInferer` tambi√©n conocido como `BradleyCooperInferer` se infiere el tipo mas especifico y se verifica q este tipo se conforme con el tipo de la anotaci√≥n, aqu√≠ se incluyen los chequeos para los `case`, verificar que los operadores aritm√©ticos solo puedan ser utilizados con `Int`,  etc. Es necesario destacar aqu√≠ el uso de dos tipos inferidos para cada nodo, un `inferred_type` y un `execution_inferred_type`. Esto ultimo se usa por la siguiente raz√≥n:

‚Äã	Asumamos que tenemos una clase `A` en la que se define un m√©todo `bar` que devuelve `self` y `foo` devolviendo `true`.  y que tambi√©n tenemos una clase hija `B` que sobrescribe `bar` devolviendo `self` pero anotado como `A` y `foo` retornando `false` . En el proceso de chequeo de tipos `B.test()` tiene q devolver `A` ya que as√≠ esta anotado, pero es necesario saber que el tipo real es `B` en el proceso de ejecuci√≥n. Pues `B.bar().foo()` deber√≠a retornar `false` como esta definido en `self`(`B`) 

**Errores detectados**:

- Incompatibilidad de tipos
- Uso de variables, tipos y m√©todos no definidos
- mal usos del `case` 



## COOL a CIL

CIL es un lenguaje intermedio 3-address pero a su vez orientado a objetos, esto nos facilita el mapeo de la mayor√≠a de las expresiones COOL a nodos de un AST de CIL. Se toma como caso interesante la instrucci√≥n `case`, en la cual se ordenan las ramas con un orden topol√≥gico, donde `a` tiene una arista hacia `b` si `a` se conforma con `b`. Luego la ejecuci√≥n se realiza en este orden. Luego por cada tipo en el programa verificamos si este se conforma con el tipo de la instrucci√≥n `case` y no ha sido usado anteriormente. Aqu√≠ se manejan errores lanzados en ejecuci√≥n como excepciones aritm√©ticas o √≠ndices fuera de rango. Las principales secciones del c√≥digo CIL, en este caso representado mediante el AST, son:

- `.TYPE`: se guarda lo que en equivalencia se puede llamar las clases, aunque no hay ning√∫n inicializado por defecto y los m√©todos lo que contienen es como una referencia a la definici√≥n real de la funci√≥n que se implementar√° en `.CODE`
- `.DATA`: se declaran las variables que representan valores constantes en la ejecuci√≥n.
- `.CODE`: implementaci√≥n de las funciones que son referenciadas en las definiciones de clases, con la particularidad que la primera es la que representa el inicio del programa; lo que comunmente es el m√©todo main.

**Errores detectados**:

- Dispatch desde void
- Index out of range
- Ejecuci√≥n de un *case* sin que ocurra alg√∫n emparejamiento con alguna rama.
- Divisi√≥n por cero

## CIL a MIPS


A la hora de traducir de c√≥digo CIL a MIPS es necesario apoyarse del patr√≥n visitor nuevamente que tiene como punto de partida el AST de CIL que genera el paso anterior. El c√≥digo MIPS tiene dos secciones que lo divide: .DATA (se crean referencias a objetos con un valor predeterminado o a otras direcciones de memoria) y .TEXT( se define como tal la l√≥gica del c√≥digo con las instrucciones que esto conlleva). Despu√©s se realiza otro visitor sencillo donde se traduce el AST de MIPS a c√≥digo en s√≠, cada intrucci√≥n recibe una representaci√≥n en un string y esto posteriormente en un archivo que finalmente ser√° ejecutado en SPIM. 
### CIL Type en memoria.

Al no soportar MIPS instrucciones orientadas a objetos es necesario elaborar una variante para la representaci√≥n de un tipo de CIL, necesitamos para esto el nombre del tipo. Para almacenar los datos del objeto se utilizo el patr√≥n *Prototype*, algo parecido a lo que realiza JavaScript con sus objetos. Para cada tipo existe un prototype el cual es copiado a la direcci√≥n del objeto creado en cada creaci√≥n almacenando tambi√©n en el prototype los valores por defecto de cada objeto. Luego para los m√©todos del objeto se almacenan sus direcciones en lo que es conocido como `tabla dispatch`:

En conclusi√≥n, los prototypes se usan como valor por default de un objeto de un tipo especifico a la hora de su creaci√≥n, todo tipo tiene un prototype asignado.

### Objetos en MIPS.
La representaci√≥n de un objeto en CIL una vez que se traduce a MIPS seria la siguiente:

 - Type(`1 word`): es un mapeo a un n√∫mero entero que mapea a un tipo. La lista `shells_table` permite acceder al espacio de memoria donde est√° almacenado el tipo a trav√©s de ese n√∫mero entero que hace funci√≥n de √≠ndice. 
 - Size (`1 word`): tama√±o en words del tipo. La suma de la cantidad de atributos + 3 (estos campos que se est√°n explicando en este momento).
 - DispatchTable (`1 word`): Direcci√≥n a la tabla dispatch del objeto. Esta contiene las direcciones de las funciones del tipo como tal.
 - Attributes (`n words`):  Direcciones de los atributos en memoria, estos se almacenan con el nombre de la clase y el nombre del atributo.

Un objeto cuya direcci√≥n inicial en memoria sea x queda de la siguiente forma:

| Direcci√≥n x | Direcci√≥n x + 4 | Direcci√≥n x + 8      | Direcci√≥n x + 8      |... | Direcci√≥n x + (a + 2 ) * 4 |
| ----------- | --------------- | ---------------------| ---------------------|--- | -------------------------- |
| Tipo        | Tama√±o          | Tabla de dispatch    | Atributo $0$         |... | Atributo $a$               |


**Llamado din√°mico a una funci√≥n**

Para cada tipo, se guardan sus m√©todos en una lista llamada type_\<tipo>_dispatch. Esta tiene la siguiente estructura, partiendo de que su inicio es en la direcci√≥n x.

| Direcci√≥n x | Direcci√≥n x + 4 | Direcci√≥n x  + 8 | ... | Direcci√≥n x + (m-1) * 4 |
| ----------- | --------------- | ---------------- | --- | ----------------------- |
| M√©todo 0    | M√©todo 1        | M√©todo 2         | ... | M√©todo m-1              |

Por cada uno de los tipos se crea una de estas tablas, que contiene (cantidad de m√©todos) * words espacio de memoria asignado. Cada elemento entonces apunta a la eiqueta donde se define la funci√≥n.

Dichas funciones  en la lista est√°n en el orden en el que fueron definidos, que si heredan por defecto vienen con los m√©todos de los ancestros en su inicio a trav√©s del procesamiento para generar el c√≥digo CIL.

Una vez que se tiene el tipo al que se le realiza el llamado, dada la estructura del objeto es f√°cil saber a que dispatch table se requiere hacer la visita. Con el apoyo de un √≠ndice se accede entonces al m√©todo apropiado.

| Direcci√≥n $x$  | Direcci√≥n $x + 4$ | Direcci√≥n $x + 8$ | ... | Direcci√≥n $x + (n-1) * 4$ |
| -------------- | ----------------- | ----------------- | --- | ------------------------- |
| _dispatch_ $0$ | _dispatch_ $1$    | _dispatch_ $2$    | ... | _dispatch_ $n - 1$        |

Donde $n$ es la cantidad de tipos, los nombres de las tablas dispactch est√°n representadas con el nombre del tipo pero aqu√≠ para prop√≥sitos demostrativos se le asigna un n√∫mero entero que es el mismo que se muestra en la estructura de un objeto cuando se habla del campo `Tipo`.

Y entonces para el llamado al m√©todo deseado se hace un proceso an√°logo de indexar con un √≠ndice conocido mediante el procesamiento y las variables del c√≥digo que almacenan dicha informaci√≥n. Luego, se obtiene la direcci√≥n al m√©todo y se hace un jump a dicha etiqueta.


## Estructura
```bash 
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ cil
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ cil.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ cool_to_cil.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.pyc
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ lexer
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ base.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ block_comments.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ errors.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ strings.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __main__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ mips
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ cil_to_mips.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ mips.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ boolean_operations.py
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ IO_operations.py
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ memory_operations.py
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ string_operations.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ parser
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ast
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ arithmetic.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ atomics.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ base.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ comparison.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ expressions.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ features.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ unaries.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ errors.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ parser.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ semantics
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ast
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ arithmetics.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ atomics.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ base.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ comparison.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ declarations.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ expressions.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ unaries.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ constants.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ inference
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ deep_inferrer.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ soft_inferencer.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ tools
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ context.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ errors.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ scope.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ type.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ type_builder.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ type_collector.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ shared
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ cascade.py
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ errors.py
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ visitor.py
‚îú‚îÄ‚îÄ ast.json
‚îú‚îÄ‚îÄ coolc.sh
‚îú‚îÄ‚îÄ makefile
‚îú‚îÄ‚îÄ parser.log
‚îú‚îÄ‚îÄ parser.out
‚îî‚îÄ‚îÄ Readme.md
```

En shared se encuentran los errores base y la implementaci√≥n del patr√≥n *visitor* usando decoradores
