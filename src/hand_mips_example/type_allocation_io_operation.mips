.text
allocate_memory:
    # Funcion que devuelve en v0 una direccion con cantidad de memoria a0 bytes
    addi $v0, $zero, 9
    syscall
    jr		$ra					# jump to $ra

init_type_io:
    # Funcion que inicializa el espacio de memoria reservado para el tipo. 
    # La direccion es recibida en a0  
    la		$t1, type_io		# Carga la direccion del tipo en el registro t1
    sw		$a0, 0($t1)		# Guarda en la primera word de la direccion de memoria de la instancia
                            # la direccion al padre del tipo type_io, en este caso type_object
    # No hay atributos, pero la idea sería ir llamado en orden como esta en CIL
    move 	$v0, $a0		# $v0 = $a0 Como convenio en v0 se guarda el valor de retorno
    jr		$ra					# jump to $ra
    
    
function_call_example:
    addi	$sp, $sp, -24		# $sp = $sp + -24
    

# Entry function
main:
    # SECCION DE ALLOCATE IO
    la		$t1, type_io		# Carga la direccion del tipo en el registro t1
    lw $t1, 4($t1)              # Recupera el tamaño de instancia del tipo
    move 	$a0, $t1		# $a0 = $t1 Pon en a0 el tamaño en bytes de la instancia
    jal		allocate_memory				# jump to allocate_memory and save position to $ra. 
                                        # Devuelve la direccion sin inicializar del tipo en v0
    move $a0 $v0
    jal		init_type_io				# jump to init_type_io and save position to $ra. Devuelve en 
                                        # v0 la direccion a la instancia inicializada, esta es la misma
                                        # a0
    # En v0 tengo la instancia del type_io ya completa

    # SECCION ARGs
    move $a0, $v0               # Argumento self para el llamado
    addi $a1, $zero, 20         # Argumento es 20 para el io_write_int

    # SECCION VCALL IO io_write_int
    la		$t1, type_io		# Guarda en t1 la direccion al tipo
    lw		$t1, 12($t1)		# Guarda en t1 la direccion del metodo de io_write_int
    
    # SECCION LLAMAR A FUNCION CON jr COMO NO SE PUEDE SABER EL ProgramCounter
    # hay que hacer magia negra
    
    addi	$s0, $zero, 1			# $s0 = $zero + 1
    j		save_pc_in_ra				# jump to save_pc_in_ra
    llamado:
    jr		$t1					# jump to $t1 donde esta el metodo de io_write_int del tipo IO
    save_pc_in_ra:
    jal		next_intr				# jump to next_intr and save position to $ra 
    next_intr:
    beq		$s0, $zero, final_de_llamado	# if $s0 == $zero then final_de_llamado
    move 	$s0, $zero		# $s0 = $zero
    j       llamado
    final_de_llamado:
    
    # SECCION VCALL IO abort
    la		$t1, type_io		# Guarda en t1 la direccion al tipo
    lw		$t1, 8($t1)		    # Guarda en t1 la direccion del metodo de abort
    jr		$t1					# jump to $t1 donde esta el metodo de abort del tipo IO

object_abort:
    addi $v0, $zero, 10
    syscall

object_copy:
    # $a0 self
    move 	$t0, $a0		# $a1 = $a0 a1 = self
    lw		$t1, 0($a0)		# t1 = tipo de self

    lw		$a0, 4($t1)		# a0 = tamaño de instancia
    li		$v0, 9		# $v0 = 9
    syscall # $v0 = heap space with size a0

    move 	$t1, $a0		# $t1 = $a0
    move 	$t3, $v0		# $t3 = $v0
    ble		$t1, $zero, end_loop	# if $t <= $zero then end_loop
        lw		$t2, 0($t0)		# t2 = atributo
        sw		$t2, 0($t3)		# atributo = t2
        
        addi		$t0, $t0, 4		
        addi		$t3, $t3, 4		
        addi	$t1, $t1, -1			# $t1 = $t1 + -1
        
    end_loop:    
    

io_write_int:
    # $a0 self instancia de IO
    # $a1 el numero a printear
    move $t0, $a0
    move $a0, $a1
    addi $v0, $zero, 1
    syscall
    move $a0, $t0
    jr		$ra					# jump to $ra
    

.data

# Father: Void, Instance byte amount required (IBAR): 4, Methods: object_abort
type_object: .word 0, 4, object_abort
# Father: Object, IBAR: 4, Methods: object_abort, io_write_int
type_io: .word type_object, 4, object_abort, io_write_int
