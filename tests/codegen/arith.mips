.data
_______error______: .asciiz "Abort called from class "
_______null_______: .asciiz "null"
_______endline_______: .asciiz "\n"
_______void_str_______: .asciiz ""
Bool_parents: .word 1, 2, 0, 
Bool_Name: .asciiz "Bool"
Bool: .word Bool_Name, 2, Bool_parents, Object_abort, Object_copy, Object_type_name, 
Int_parents: .word 1, 3, 0, 
Int_Name: .asciiz "Int"
Int: .word Int_Name, 2, Int_parents, Object_abort, Object_copy, Object_type_name, 
String_parents: .word 1, 4, 0, 
String_Name: .asciiz "String"
String: .word String_Name, 2, String_parents, Object_abort, Object_copy, Object_type_name, String_concat, String_length, String_substr, 
SELF_TYPE_parents: .word 1, 5, 0, 
SELF_TYPE_Name: .asciiz "SELF_TYPE"
SELF_TYPE: .word SELF_TYPE_Name, 1, SELF_TYPE_parents, Object_abort, Object_copy, Object_type_name, 
Object_parents: .word 1, 0, 
Object_Name: .asciiz "Object"
Object: .word Object_Name, 1, Object_parents, Object_abort, Object_copy, Object_type_name, 
IO_parents: .word 1, 6, 0, 
IO_Name: .asciiz "IO"
IO: .word IO_Name, 1, IO_parents, Object_abort, Object_copy, Object_type_name, IO_in_int, IO_in_string, IO_out_int, IO_out_string, 
A_parents: .word 1, 7, 0, 
A_Name: .asciiz "A"
A: .word A_Name, 2, A_parents, Object_abort, Object_copy, Object_type_name, A_value, A_set_var, A_method1, A_method2, A_method3, A_method4, A_method5, 
B_parents: .word 1, 7, 8, 0, 
B_Name: .asciiz "B"
B: .word B_Name, 2, B_parents, Object_abort, Object_copy, Object_type_name, A_value, A_set_var, A_method1, A_method2, A_method3, A_method4, B_method5, 
C_parents: .word 1, 7, 8, 9, 0, 
C_Name: .asciiz "C"
C: .word C_Name, 2, C_parents, Object_abort, Object_copy, Object_type_name, A_value, A_set_var, A_method1, A_method2, A_method3, A_method4, C_method5, C_method6, 
D_parents: .word 1, 7, 8, 10, 0, 
D_Name: .asciiz "D"
D: .word D_Name, 2, D_parents, Object_abort, Object_copy, Object_type_name, A_value, A_set_var, A_method1, A_method2, A_method3, A_method4, B_method5, D_method7, 
E_parents: .word 1, 7, 8, 10, 11, 0, 
E_Name: .asciiz "E"
E: .word E_Name, 2, E_parents, Object_abort, Object_copy, Object_type_name, A_value, A_set_var, A_method1, A_method2, A_method3, A_method4, B_method5, D_method7, E_method6, 
A2I_parents: .word 1, 12, 0, 
A2I_Name: .asciiz "A2I"
A2I: .word A2I_Name, 1, A2I_parents, Object_abort, Object_copy, Object_type_name, A2I_c2i, A2I_i2c, A2I_a2i, A2I_a2i_aux, A2I_i2a, A2I_i2a_aux, 
Main_parents: .word 1, 6, 13, 0, 
Main_Name: .asciiz "Main"
Main: .word Main_Name, 5, Main_parents, Object_abort, Object_copy, Object_type_name, IO_in_int, IO_in_string, IO_out_int, IO_out_string, Main_menu, Main_prompt, Main_get_int, Main_is_even, Main_class_type, Main_print, Main_main, 
string_0: .asciiz "0"
string_1: .asciiz "1"
string_2: .asciiz "2"
string_3: .asciiz "3"
string_4: .asciiz "4"
string_5: .asciiz "5"
string_6: .asciiz "6"
string_7: .asciiz "7"
string_8: .asciiz "8"
string_9: .asciiz "9"
string_10: .asciiz ""
string_11: .asciiz "9"
string_12: .asciiz "8"
string_13: .asciiz "7"
string_14: .asciiz "6"
string_15: .asciiz "5"
string_16: .asciiz "4"
string_17: .asciiz "3"
string_18: .asciiz "2"
string_19: .asciiz "1"
string_20: .asciiz "0"
string_21: .asciiz "-"
string_22: .asciiz "+"
string_23: .asciiz "-"
string_24: .asciiz "0"
string_25: .asciiz ""
string_26: .asciiz "\n	To add a number to "
string_27: .asciiz "...enter a:\n"
string_28: .asciiz "	To negate "
string_29: .asciiz "...enter b:\n"
string_30: .asciiz "	To find the difference between "
string_31: .asciiz "and another number...enter c:\n"
string_32: .asciiz "	To find the factorial of "
string_33: .asciiz "...enter d:\n"
string_34: .asciiz "	To square "
string_35: .asciiz "...enter e:\n"
string_36: .asciiz "	To cube "
string_37: .asciiz "...enter f:\n"
string_38: .asciiz "	To find out if "
string_39: .asciiz "is a multiple of 3...enter g:\n"
string_40: .asciiz "	To divide "
string_41: .asciiz "by 8...enter h:\n"
string_42: .asciiz "	To get a new number...enter j:\n"
string_43: .asciiz "	To quit...enter q:\n\n"
string_44: .asciiz "\n"
string_45: .asciiz "Please enter a number...  "
string_46: .asciiz "Class type is now E\n"
string_47: .asciiz "Class type is now D\n"
string_48: .asciiz "Class type is now C\n"
string_49: .asciiz "Class type is now B\n"
string_50: .asciiz "Class type is now A\n"
string_51: .asciiz "Oooops\n"
string_52: .asciiz " "
string_53: .asciiz "number "
string_54: .asciiz "is odd!\n"
string_55: .asciiz "is even!\n"
string_56: .asciiz "a"
string_57: .asciiz "b"
string_58: .asciiz "c"
string_59: .asciiz "d"
string_60: .asciiz "e"
string_61: .asciiz "f"
string_62: .asciiz "g"
string_63: .asciiz "h"
string_64: .asciiz "j"
string_65: .asciiz "q"
string_66: .asciiz "number "
string_67: .asciiz "is equal to "
string_68: .asciiz "times 8 with a remainder of "
string_69: .asciiz "\n"
string_70: .asciiz "number "
string_71: .asciiz "is not divisible by 3.\n"
string_72: .asciiz "number "
string_73: .asciiz "is divisible by 3.\n"
string_74: .asciiz "Oooops\n"

.text
.globl main
main:     #
addi $sp, $sp, -4     #Push local var self stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion main
#Allocate a una class Main
#atributo type_name en puntero + 0
#atributo char en puntero + 4
#atributo avar en puntero + 8
#atributo a_var en puntero + 12
#atributo flag en puntero + 16
li $a0, 20      #
li $v0, 9      #
syscall
sw $v0, 4($sp)      #Guardando en la variable local self puntero de la instancia de la clase Main
#Assignacion de la insformacion de tipo a Main
la $t0, Main      #
move $s4, $t0      #
lw $t0, 4($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 4($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
jal new_ctr_Main                               #
lw $t0, 4($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
jal Main_main                               #
li $v0, 10      #
syscall

new_ctr_Main:     #
#Parametro self en stackpoiner + 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion new_ctr_Main
lw $t0, 4($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
jal new_ctr_IO                               #
la $t0, _______void_str_______      #
move $s4, $t0      #
lw $s6, 4($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
move $s4, $v0      #
lw $t0, 4($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded char
sw $t1, 4($t0)      #Setea la propiedad char con el valor de _
la $t0, _______null_______      #
move $s4, $t0      #
lw $t0, 4($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded avar
sw $t1, 8($t0)      #Setea la propiedad avar con el valor de _
la $t0, _______null_______      #
move $s4, $t0      #
lw $t0, 4($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded a_var
sw $t1, 12($t0)      #Setea la propiedad a_var con el valor de _
#Assignando el resultado de la expression al atributo flag de la clase Main
li $s4, 1      #
lw $s6, 4($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
lw $s6, 4($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __bool__new__                               #
move $s4, $v0      #
lw $t0, 4($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded flag
sw $t1, 16($t0)      #Setea la propiedad flag con el valor de _
#Fin De la Asignacion
lw $v0, 4($sp)      #Return self
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 8     #
jr $ra                               #

Main_main:     #
#Parametro self en stackpoiner + 436
addi $sp, $sp, -4     #Push local var new_A@0 stackpointer 432
addi $sp, $sp, -4     #Push local var param_0_to_out_string@0 stackpointer 428
addi $sp, $sp, -4     #Push local var param_0_to_print@0 stackpointer 424
addi $sp, $sp, -4     #Push local var instance_dynamic_to_value@0 stackpointer 420
addi $sp, $sp, -4     #Push local var param_0_to_is_even@0 stackpointer 416
addi $sp, $sp, -4     #Push local var param_0_to_out_string@1 stackpointer 412
addi $sp, $sp, -4     #Push local var param_0_to_out_string@2 stackpointer 408
addi $sp, $sp, -4     #Push local var param_0_to_class_type@0 stackpointer 404
addi $sp, $sp, -4     #Push local var str_eq@_a@0 stackpointer 400
addi $sp, $sp, -4     #Push local var str_eq@_b@0 stackpointer 396
addi $sp, $sp, -4     #Push local var str_eq@_a@1 stackpointer 392
addi $sp, $sp, -4     #Push local var str_eq@_b@1 stackpointer 388
addi $sp, $sp, -4     #Push local var str_eq@_a@2 stackpointer 384
addi $sp, $sp, -4     #Push local var str_eq@_b@2 stackpointer 380
addi $sp, $sp, -4     #Push local var str_eq@_a@3 stackpointer 376
addi $sp, $sp, -4     #Push local var str_eq@_b@3 stackpointer 372
addi $sp, $sp, -4     #Push local var str_eq@_a@4 stackpointer 368
addi $sp, $sp, -4     #Push local var str_eq@_b@4 stackpointer 364
addi $sp, $sp, -4     #Push local var str_eq@_a@5 stackpointer 360
addi $sp, $sp, -4     #Push local var str_eq@_b@5 stackpointer 356
addi $sp, $sp, -4     #Push local var str_eq@_a@6 stackpointer 352
addi $sp, $sp, -4     #Push local var str_eq@_b@6 stackpointer 348
addi $sp, $sp, -4     #Push local var str_eq@_a@7 stackpointer 344
addi $sp, $sp, -4     #Push local var str_eq@_b@7 stackpointer 340
addi $sp, $sp, -4     #Push local var str_eq@_a@8 stackpointer 336
addi $sp, $sp, -4     #Push local var str_eq@_b@8 stackpointer 332
addi $sp, $sp, -4     #Push local var str_eq@_a@9 stackpointer 328
addi $sp, $sp, -4     #Push local var str_eq@_b@9 stackpointer 324
addi $sp, $sp, -4     #Push local var new_A@1 stackpointer 320
addi $sp, $sp, -4     #Push local var instance_dynamic_to_method1@0 stackpointer 316
addi $sp, $sp, -4     #Push local var instance_dynamic_to_value@1 stackpointer 312
addi $sp, $sp, -4     #Push local var param_0_to_method1@0 stackpointer 308
addi $sp, $sp, -4     #Push local var new_A@2 stackpointer 304
addi $sp, $sp, -4     #Push local var x stackpointer 300
addi $sp, $sp, -4     #Push local var new_E@0 stackpointer 296
addi $sp, $sp, -4     #Push local var instance_dynamic_to_method6@0 stackpointer 292
addi $sp, $sp, -4     #Push local var instance_dynamic_to_value@2 stackpointer 288
addi $sp, $sp, -4     #Push local var param_0_to_method6@0 stackpointer 284
addi $sp, $sp, -4     #Push local var r stackpointer 280
addi $sp, $sp, -4     #Push local var rest@_a@0 stackpointer 276
addi $sp, $sp, -4     #Push local var rest@_b@0 stackpointer 272
addi $sp, $sp, -4     #Push local var instance_dynamic_to_value@3 stackpointer 268
addi $sp, $sp, -4     #Push local var factor@_a@0 stackpointer 264
addi $sp, $sp, -4     #Push local var factor@_b@0 stackpointer 260
addi $sp, $sp, -4     #Push local var instance_dynamic_to_value@4 stackpointer 256
addi $sp, $sp, -4     #Push local var param_0_to_out_string@3 stackpointer 252
addi $sp, $sp, -4     #Push local var param_0_to_print@1 stackpointer 248
addi $sp, $sp, -4     #Push local var param_0_to_out_string@4 stackpointer 244
addi $sp, $sp, -4     #Push local var param_0_to_print@2 stackpointer 240
addi $sp, $sp, -4     #Push local var param_0_to_out_string@5 stackpointer 236
addi $sp, $sp, -4     #Push local var a stackpointer 232
addi $sp, $sp, -4     #Push local var new_A2I@0 stackpointer 228
addi $sp, $sp, -4     #Push local var instance_dynamic_to_i2a@0 stackpointer 224
addi $sp, $sp, -4     #Push local var param_0_to_i2a@0 stackpointer 220
addi $sp, $sp, -4     #Push local var param_0_to_out_string@6 stackpointer 216
addi $sp, $sp, -4     #Push local var param_0_to_out_string@7 stackpointer 212
addi $sp, $sp, -4     #Push local var new_D@0 stackpointer 208
addi $sp, $sp, -4     #Push local var instance_dynamic_to_method7@0 stackpointer 204
addi $sp, $sp, -4     #Push local var instance_dynamic_to_value@5 stackpointer 200
addi $sp, $sp, -4     #Push local var param_0_to_method7@0 stackpointer 196
addi $sp, $sp, -4     #Push local var param_0_to_out_string@8 stackpointer 192
addi $sp, $sp, -4     #Push local var param_0_to_print@3 stackpointer 188
addi $sp, $sp, -4     #Push local var param_0_to_out_string@9 stackpointer 184
addi $sp, $sp, -4     #Push local var param_0_to_out_string@10 stackpointer 180
addi $sp, $sp, -4     #Push local var param_0_to_print@4 stackpointer 176
addi $sp, $sp, -4     #Push local var param_0_to_out_string@11 stackpointer 172
addi $sp, $sp, -4     #Push local var new_C@0 stackpointer 168
addi $sp, $sp, -4     #Push local var instance_C_to_method5@0 stackpointer 164
addi $sp, $sp, -4     #Push local var instance_dynamic_to_value@6 stackpointer 160
addi $sp, $sp, -4     #Push local var param_0_to_method5@0 stackpointer 156
addi $sp, $sp, -4     #Push local var new_C@1 stackpointer 152
addi $sp, $sp, -4     #Push local var instance_B_to_method5@0 stackpointer 148
addi $sp, $sp, -4     #Push local var instance_dynamic_to_value@7 stackpointer 144
addi $sp, $sp, -4     #Push local var param_0_to_method5@1 stackpointer 140
addi $sp, $sp, -4     #Push local var new_C@2 stackpointer 136
addi $sp, $sp, -4     #Push local var instance_A_to_method5@0 stackpointer 132
addi $sp, $sp, -4     #Push local var instance_dynamic_to_value@8 stackpointer 128
addi $sp, $sp, -4     #Push local var param_0_to_method5@2 stackpointer 124
addi $sp, $sp, -4     #Push local var new_A@3 stackpointer 120
addi $sp, $sp, -4     #Push local var instance_dynamic_to_set_var@0 stackpointer 116
addi $sp, $sp, -4     #Push local var param_0_to_set_var@0 stackpointer 112
addi $sp, $sp, -4     #Push local var new_D@1 stackpointer 108
addi $sp, $sp, -4     #Push local var instance_dynamic_to_method4@0 stackpointer 104
addi $sp, $sp, -4     #Push local var instance_dynamic_to_value@9 stackpointer 100
addi $sp, $sp, -4     #Push local var param_0_to_method4@0 stackpointer 96
addi $sp, $sp, -4     #Push local var instance_dynamic_to_value@10 stackpointer 92
addi $sp, $sp, -4     #Push local var param_1_to_method4@0 stackpointer 88
addi $sp, $sp, -4     #Push local var cond@expr@value@0 stackpointer 84
addi $sp, $sp, -4     #Push local var cond@type@0 stackpointer 80
addi $sp, $sp, -4     #Push local var c stackpointer 76
addi $sp, $sp, -4     #Push local var instance_dynamic_to_method6@1 stackpointer 72
addi $sp, $sp, -4     #Push local var instance_dynamic_to_value@11 stackpointer 68
addi $sp, $sp, -4     #Push local var param_0_to_method6@1 stackpointer 64
addi $sp, $sp, -4     #Push local var a stackpointer 60
addi $sp, $sp, -4     #Push local var instance_dynamic_to_method3@0 stackpointer 56
addi $sp, $sp, -4     #Push local var instance_dynamic_to_value@12 stackpointer 52
addi $sp, $sp, -4     #Push local var param_0_to_method3@0 stackpointer 48
addi $sp, $sp, -4     #Push local var o stackpointer 44
addi $sp, $sp, -4     #Push local var param_0_to_out_string@12 stackpointer 40
addi $sp, $sp, -4     #Push local var new_A@4 stackpointer 36
addi $sp, $sp, -4     #Push local var instance_dynamic_to_set_var@1 stackpointer 32
addi $sp, $sp, -4     #Push local var param_0_to_set_var@1 stackpointer 28
addi $sp, $sp, -4     #Push local var new_B@0 stackpointer 24
addi $sp, $sp, -4     #Push local var instance_dynamic_to_method2@0 stackpointer 20
addi $sp, $sp, -4     #Push local var instance_dynamic_to_value@13 stackpointer 16
addi $sp, $sp, -4     #Push local var param_0_to_method2@0 stackpointer 12
addi $sp, $sp, -4     #Push local var instance_dynamic_to_value@14 stackpointer 8
addi $sp, $sp, -4     #Push local var param_1_to_method2@0 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion Main_main
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Asignando un nuevo valor a la variable avar
#Creando instancia de tipo A
#Allocate a una class A
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 432($sp)      #Guardando en la variable local new_A@0 puntero de la instancia de la clase A
#Assignacion de la insformacion de tipo a la instancia
la $t0, A      #
move $s4, $t0      #
lw $t0, 432($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 432($sp)      #Lee el valor de la var new_A@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_A@0
jal new_ctr_A                               #
move $s4, $v0      #Asigna el resultado de la funcion
lw $t0, 436($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded avar
sw $t1, 8($t0)      #Setea la propiedad avar con el valor de _
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
move $s4, $t1      #Guarda el valor de la propiedad avar en la variable local _
#Inicio del paso 1 de una sequencia Block
#Inicio de un While
j while_cond_2                               #
while_back_2:
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_53      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 428($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 432($sp)      #Lee el valor de la var param_0_to_out_string@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@0
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 1 de una sequencia Block
#StaticDispatch print
#Evalua el parametro 0 para el CastingDispatch print
#Get Self Property avar
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 424($sp)      #Guarda el valor de la propiedad avar en la variable local param_0_to_print@0
#Fin del paramentro 0 al CastingDispatch print
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 428($sp)      #Lee el valor de la var param_0_to_print@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_print@0
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 60($t1)      #Buscando el metodo dinamico para la funcion print
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 2 de una sequencia Block
#Evalua la condicion de un If
#StaticDispatch is_even
#Evalua el parametro 0 para el CastingDispatch is_even
#Evalua la Expresion para el DinamicDispatch value
#Get Self Property avar
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 420($sp)      #Guarda el valor de la propiedad avar en la variable local instance_dynamic_to_value@0
#Fin de la exprecion previa al DinamicDispatch value
lw $t0, 420($sp)      #Lee el valor de la var instance_dynamic_to_value@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_value@0
lw $t0, 424($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion value
jal $t3                               #
sw $v0, 416($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch is_even
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 420($sp)      #Lee el valor de la var param_0_to_is_even@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_is_even@0
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 52($t1)      #Buscando el metodo dinamico para la funcion is_even
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_Main_main_0     #
#Else case
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_54      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 412($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 416($sp)      #Lee el valor de la var param_0_to_out_string@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@1
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
j fin_Main_main_0                               #
then_Main_main_0:
#Then case
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_55      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 408($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 412($sp)      #Lee el valor de la var param_0_to_out_string@2
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@2
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
fin_Main_main_0:
#Fin de un If
#Inicio del paso 3 de una sequencia Block
#StaticDispatch class_type
#Evalua el parametro 0 para el CastingDispatch class_type
#Get Self Property avar
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 404($sp)      #Guarda el valor de la propiedad avar en la variable local param_0_to_class_type@0
#Fin del paramentro 0 al CastingDispatch class_type
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 408($sp)      #Lee el valor de la var param_0_to_class_type@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_class_type@0
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 56($t1)      #Buscando el metodo dinamico para la funcion class_type
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 4 de una sequencia Block
#Asignando un nuevo valor a la variable char
#StaticDispatch menu
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 440($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 40($t1)      #Buscando el metodo dinamico para la funcion menu
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
lw $t0, 436($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded char
sw $t1, 4($t0)      #Setea la propiedad char con el valor de _
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 4($t0)      #Lee la propiedad char
move $s4, $t1      #Guarda el valor de la propiedad char en la variable local _
#Inicio del paso 5 de una sequencia Block
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Self Property char
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 4($t0)      #Lee la propiedad char
sw $t1, 400($sp)      #Guarda el valor de la propiedad char en la variable local str_eq@_a@0
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_56      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 396($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 436($sp)      #Guarda self
lw $a0, 400($sp)      #Guarda el parametro 0 -> str_eq@_a@0
lw $a1, 396($sp)      #Guarda el parametro 1 -> str_eq@_b@0
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 436($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_Main_main_1     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Self Property char
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 4($t0)      #Lee la propiedad char
sw $t1, 392($sp)      #Guarda el valor de la propiedad char en la variable local str_eq@_a@1
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_57      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 388($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 436($sp)      #Guarda self
lw $a0, 392($sp)      #Guarda el parametro 0 -> str_eq@_a@1
lw $a1, 388($sp)      #Guarda el parametro 1 -> str_eq@_b@1
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 436($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_Main_main_2     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Self Property char
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 4($t0)      #Lee la propiedad char
sw $t1, 384($sp)      #Guarda el valor de la propiedad char en la variable local str_eq@_a@2
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_58      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 380($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 436($sp)      #Guarda self
lw $a0, 384($sp)      #Guarda el parametro 0 -> str_eq@_a@2
lw $a1, 380($sp)      #Guarda el parametro 1 -> str_eq@_b@2
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 436($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_Main_main_3     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Self Property char
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 4($t0)      #Lee la propiedad char
sw $t1, 376($sp)      #Guarda el valor de la propiedad char en la variable local str_eq@_a@3
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_59      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 372($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 436($sp)      #Guarda self
lw $a0, 376($sp)      #Guarda el parametro 0 -> str_eq@_a@3
lw $a1, 372($sp)      #Guarda el parametro 1 -> str_eq@_b@3
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 436($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_Main_main_4     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Self Property char
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 4($t0)      #Lee la propiedad char
sw $t1, 368($sp)      #Guarda el valor de la propiedad char en la variable local str_eq@_a@4
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_60      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 364($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 436($sp)      #Guarda self
lw $a0, 368($sp)      #Guarda el parametro 0 -> str_eq@_a@4
lw $a1, 364($sp)      #Guarda el parametro 1 -> str_eq@_b@4
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 436($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_Main_main_5     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Self Property char
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 4($t0)      #Lee la propiedad char
sw $t1, 360($sp)      #Guarda el valor de la propiedad char en la variable local str_eq@_a@5
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_61      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 356($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 436($sp)      #Guarda self
lw $a0, 360($sp)      #Guarda el parametro 0 -> str_eq@_a@5
lw $a1, 356($sp)      #Guarda el parametro 1 -> str_eq@_b@5
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 436($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_Main_main_6     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Self Property char
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 4($t0)      #Lee la propiedad char
sw $t1, 352($sp)      #Guarda el valor de la propiedad char en la variable local str_eq@_a@6
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_62      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 348($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 436($sp)      #Guarda self
lw $a0, 352($sp)      #Guarda el parametro 0 -> str_eq@_a@6
lw $a1, 348($sp)      #Guarda el parametro 1 -> str_eq@_b@6
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 436($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_Main_main_7     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Self Property char
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 4($t0)      #Lee la propiedad char
sw $t1, 344($sp)      #Guarda el valor de la propiedad char en la variable local str_eq@_a@7
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_63      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 340($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 436($sp)      #Guarda self
lw $a0, 344($sp)      #Guarda el parametro 0 -> str_eq@_a@7
lw $a1, 340($sp)      #Guarda el parametro 1 -> str_eq@_b@7
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 436($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_Main_main_8     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Self Property char
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 4($t0)      #Lee la propiedad char
sw $t1, 336($sp)      #Guarda el valor de la propiedad char en la variable local str_eq@_a@8
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_64      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 332($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 436($sp)      #Guarda self
lw $a0, 336($sp)      #Guarda el parametro 0 -> str_eq@_a@8
lw $a1, 332($sp)      #Guarda el parametro 1 -> str_eq@_b@8
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 436($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_Main_main_9     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Self Property char
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 4($t0)      #Lee la propiedad char
sw $t1, 328($sp)      #Guarda el valor de la propiedad char en la variable local str_eq@_a@9
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_65      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 324($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 436($sp)      #Guarda self
lw $a0, 328($sp)      #Guarda el parametro 0 -> str_eq@_a@9
lw $a1, 324($sp)      #Guarda el parametro 1 -> str_eq@_b@9
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 436($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_Main_main_10     #
#Else case
#Asignando un nuevo valor a la variable avar
#Evalua la Expresion para el DinamicDispatch method1
#Creando instancia de tipo A
#Allocate a una class A
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 320($sp)      #Guardando en la variable local new_A@1 puntero de la instancia de la clase A
#Assignacion de la insformacion de tipo a la instancia
la $t0, A      #
move $s4, $t0      #
lw $t0, 320($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 320($sp)      #Lee el valor de la var new_A@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_A@1
jal new_ctr_A                               #
sw $v0, 316($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch method1
#Evalua el parametro 0 para el CastingDispatch method1
#Evalua la Expresion para el DinamicDispatch value
#Get Self Property avar
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 312($sp)      #Guarda el valor de la propiedad avar en la variable local instance_dynamic_to_value@1
#Fin de la exprecion previa al DinamicDispatch value
lw $t0, 312($sp)      #Lee el valor de la var instance_dynamic_to_value@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_value@1
lw $t0, 316($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion value
jal $t3                               #
sw $v0, 308($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch method1
lw $t0, 316($sp)      #Lee el valor de la var instance_dynamic_to_method1@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_method1@0
lw $t0, 312($sp)      #Lee el valor de la var param_0_to_method1@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_method1@0
lw $t0, 324($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 32($t1)      #Buscando el metodo dinamico para la funcion method1
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
lw $t0, 436($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded avar
sw $t1, 8($t0)      #Setea la propiedad avar con el valor de _
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
move $s4, $t1      #Guarda el valor de la propiedad avar en la variable local _
j fin_Main_main_10                               #
then_Main_main_10:
#Then case
#Asignando un nuevo valor a la variable flag
li $s4, 0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __bool__new__                               #
move $s4, $v0      #
lw $t0, 436($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded flag
sw $t1, 16($t0)      #Setea la propiedad flag con el valor de _
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 16($t0)      #Lee la propiedad flag
move $s4, $t1      #Guarda el valor de la propiedad flag en la variable local _
fin_Main_main_10:
#Fin de un If
j fin_Main_main_9                               #
then_Main_main_9:
#Then case
#Asignando un nuevo valor a la variable avar
#Creando instancia de tipo A
#Allocate a una class A
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 304($sp)      #Guardando en la variable local new_A@2 puntero de la instancia de la clase A
#Assignacion de la insformacion de tipo a la instancia
la $t0, A      #
move $s4, $t0      #
lw $t0, 304($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 304($sp)      #Lee el valor de la var new_A@2
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_A@2
jal new_ctr_A                               #
move $s4, $v0      #Asigna el resultado de la funcion
lw $t0, 436($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded avar
sw $t1, 8($t0)      #Setea la propiedad avar con el valor de _
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
move $s4, $t1      #Guarda el valor de la propiedad avar en la variable local _
fin_Main_main_9:
#Fin de un If
j fin_Main_main_8                               #
then_Main_main_8:
#Then case
la $t0, _______null_______      #
move $s4, $t0      #
move $t0, $s4      #
sw $t0, 300($sp)      #
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Asignando un nuevo valor a la variable x
#Evalua la Expresion para el DinamicDispatch method6
#Creando instancia de tipo E
#Allocate a una class E
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 296($sp)      #Guardando en la variable local new_E@0 puntero de la instancia de la clase E
#Assignacion de la insformacion de tipo a la instancia
la $t0, E      #
move $s4, $t0      #
lw $t0, 296($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 296($sp)      #Lee el valor de la var new_E@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_E@0
jal new_ctr_E                               #
sw $v0, 292($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch method6
#Evalua el parametro 0 para el CastingDispatch method6
#Evalua la Expresion para el DinamicDispatch value
#Get Self Property avar
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 288($sp)      #Guarda el valor de la propiedad avar en la variable local instance_dynamic_to_value@2
#Fin de la exprecion previa al DinamicDispatch value
lw $t0, 288($sp)      #Lee el valor de la var instance_dynamic_to_value@2
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_value@2
lw $t0, 292($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion value
jal $t3                               #
sw $v0, 284($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch method6
lw $t0, 292($sp)      #Lee el valor de la var instance_dynamic_to_method6@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_method6@0
lw $t0, 288($sp)      #Lee el valor de la var param_0_to_method6@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_method6@0
lw $t0, 300($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de E
lw $t3, 56($t1)      #Buscando el metodo dinamico para la funcion method6
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
move $t0, $s4      #
sw $t0, 300($sp)      #
lw $t0, 300($sp)      #
move $s4, $t0      #
#Inicio del paso 1 de una sequencia Block
#Eval Expression to Let r
#Evaluando el operado izquierdo de una operacion rest
#Evalua la Expresion para el DinamicDispatch value
#Get Self Property avar
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 268($sp)      #Guarda el valor de la propiedad avar en la variable local instance_dynamic_to_value@3
#Fin de la exprecion previa al DinamicDispatch value
lw $t0, 268($sp)      #Lee el valor de la var instance_dynamic_to_value@3
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_value@3
lw $t0, 272($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion value
jal $t3                               #
sw $v0, 276($sp)      #Asigna el resultado de la funcion
#Resolucion del operado izquierdo de una operacion rest
#Evaluando el operado derecho de una operacion rest
#Evaluando el operado izquierdo de una operacion factor
#Evalua la Expresion para el DinamicDispatch value
#Get Local Var x
#Fin de la exprecion previa al DinamicDispatch value
lw $t0, 300($sp)      #Lee el valor de la var x
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con x
lw $t0, 304($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion value
jal $t3                               #
sw $v0, 264($sp)      #Asigna el resultado de la funcion
#Resolucion del operado izquierdo de una operacion factor
#Evaluando el operado derecho de una operacion factor
li $s4, 8      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 260($sp)      #
#Resolucion del operado derecha de una operacion factor
lw $s6, 436($sp)      #Guarda self
lw $a0, 264($sp)      #Guarda el parametro 0 -> factor@_a@0
lw $a1, 260($sp)      #Guarda el parametro 1 -> factor@_b@0
jal __int__mul__                               #
sw $v0, 272($sp)      #
#Resolucion del operado derecha de una operacion rest
lw $s6, 436($sp)      #Guarda self
lw $a0, 276($sp)      #Guarda el parametro 0 -> rest@_a@0
lw $a1, 272($sp)      #Guarda el parametro 1 -> rest@_b@0
jal __int__sub__                               #
sw $v0, 280($sp)      #
#Fin de la asignacion Let r
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_66      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 252($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 256($sp)      #Lee el valor de la var param_0_to_out_string@3
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@3
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 1 de una sequencia Block
#StaticDispatch print
#Evalua el parametro 0 para el CastingDispatch print
#Get Self Property avar
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 248($sp)      #Guarda el valor de la propiedad avar en la variable local param_0_to_print@1
#Fin del paramentro 0 al CastingDispatch print
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 252($sp)      #Lee el valor de la var param_0_to_print@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_print@1
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 60($t1)      #Buscando el metodo dinamico para la funcion print
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 2 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_67      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 244($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 248($sp)      #Lee el valor de la var param_0_to_out_string@4
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@4
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 3 de una sequencia Block
#StaticDispatch print
#Evalua el parametro 0 para el CastingDispatch print
#Get Local Var x
lw $t0, 300($sp)      #
sw $t0, 240($sp)      #
#Fin del paramentro 0 al CastingDispatch print
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 244($sp)      #Lee el valor de la var param_0_to_print@2
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_print@2
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 60($t1)      #Buscando el metodo dinamico para la funcion print
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 4 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_68      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 236($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 240($sp)      #Lee el valor de la var param_0_to_out_string@5
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@5
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 5 de una sequencia Block
#Eval Expression to Let a
#Creando instancia de tipo A2I
#Allocate a una class A2I
#atributo type_name en puntero + 0
li $a0, 4      #
li $v0, 9      #
syscall
sw $v0, 228($sp)      #Guardando en la variable local new_A2I@0 puntero de la instancia de la clase A2I
#Assignacion de la insformacion de tipo a la instancia
la $t0, A2I      #
move $s4, $t0      #
lw $t0, 228($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 228($sp)      #Lee el valor de la var new_A2I@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_A2I@0
jal new_ctr_A2I                               #
sw $v0, 232($sp)      #Asigna el resultado de la funcion
#Fin de la asignacion Let a
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
#Evalua la Expresion para el DinamicDispatch i2a
#Get Local Var a
lw $t0, 232($sp)      #
sw $t0, 224($sp)      #
#Fin de la exprecion previa al DinamicDispatch i2a
#Evalua el parametro 0 para el CastingDispatch i2a
#Get Local Var r
lw $t0, 280($sp)      #
sw $t0, 220($sp)      #
#Fin del paramentro 0 al CastingDispatch i2a
lw $t0, 224($sp)      #Lee el valor de la var instance_dynamic_to_i2a@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_i2a@0
lw $t0, 224($sp)      #Lee el valor de la var param_0_to_i2a@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_i2a@0
lw $t0, 232($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A2I
lw $t3, 40($t1)      #Buscando el metodo dinamico para la funcion i2a
jal $t3                               #
sw $v0, 216($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 220($sp)      #Lee el valor de la var param_0_to_out_string@6
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@6
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 1 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_69      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 212($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 216($sp)      #Lee el valor de la var param_0_to_out_string@7
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@7
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 2 de una sequencia Block
#Asignando un nuevo valor a la variable avar
#Get Local Var x
lw $t0, 300($sp)      #
move $s4, $t0      #
lw $t0, 436($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded avar
sw $t1, 8($t0)      #Setea la propiedad avar con el valor de _
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
move $s4, $t1      #Guarda el valor de la propiedad avar en la variable local _
fin_Main_main_8:
#Fin de un If
j fin_Main_main_7                               #
then_Main_main_7:
#Then case
#Evalua la condicion de un If
#Evalua la Expresion para el DinamicDispatch method7
#Creando instancia de tipo D
#Allocate a una class D
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 208($sp)      #Guardando en la variable local new_D@0 puntero de la instancia de la clase D
#Assignacion de la insformacion de tipo a la instancia
la $t0, D      #
move $s4, $t0      #
lw $t0, 208($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 208($sp)      #Lee el valor de la var new_D@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_D@0
jal new_ctr_D                               #
sw $v0, 204($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch method7
#Evalua el parametro 0 para el CastingDispatch method7
#Evalua la Expresion para el DinamicDispatch value
#Get Self Property avar
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 200($sp)      #Guarda el valor de la propiedad avar en la variable local instance_dynamic_to_value@5
#Fin de la exprecion previa al DinamicDispatch value
lw $t0, 200($sp)      #Lee el valor de la var instance_dynamic_to_value@5
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_value@5
lw $t0, 204($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion value
jal $t3                               #
sw $v0, 196($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch method7
lw $t0, 204($sp)      #Lee el valor de la var instance_dynamic_to_method7@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_method7@0
lw $t0, 200($sp)      #Lee el valor de la var param_0_to_method7@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_method7@0
lw $t0, 212($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de D
lw $t3, 52($t1)      #Buscando el metodo dinamico para la funcion method7
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_Main_main_11     #
#Else case
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_70      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 192($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 196($sp)      #Lee el valor de la var param_0_to_out_string@8
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@8
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 1 de una sequencia Block
#StaticDispatch print
#Evalua el parametro 0 para el CastingDispatch print
#Get Self Property avar
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 188($sp)      #Guarda el valor de la propiedad avar en la variable local param_0_to_print@3
#Fin del paramentro 0 al CastingDispatch print
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 192($sp)      #Lee el valor de la var param_0_to_print@3
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_print@3
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 60($t1)      #Buscando el metodo dinamico para la funcion print
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 2 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_71      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 184($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 188($sp)      #Lee el valor de la var param_0_to_out_string@9
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@9
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
j fin_Main_main_11                               #
then_Main_main_11:
#Then case
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_72      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 180($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 184($sp)      #Lee el valor de la var param_0_to_out_string@10
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@10
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 1 de una sequencia Block
#StaticDispatch print
#Evalua el parametro 0 para el CastingDispatch print
#Get Self Property avar
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 176($sp)      #Guarda el valor de la propiedad avar en la variable local param_0_to_print@4
#Fin del paramentro 0 al CastingDispatch print
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 180($sp)      #Lee el valor de la var param_0_to_print@4
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_print@4
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 60($t1)      #Buscando el metodo dinamico para la funcion print
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 2 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_73      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 172($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 176($sp)      #Lee el valor de la var param_0_to_out_string@11
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@11
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
fin_Main_main_11:
#Fin de un If
fin_Main_main_7:
#Fin de un If
j fin_Main_main_6                               #
then_Main_main_6:
#Then case
#Asignando un nuevo valor a la variable avar
#Evalua la Expresion para el CastingDispatch method5
#Creando instancia de tipo C
#Allocate a una class C
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 168($sp)      #Guardando en la variable local new_C@0 puntero de la instancia de la clase C
#Assignacion de la insformacion de tipo a la instancia
la $t0, C      #
move $s4, $t0      #
lw $t0, 168($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 168($sp)      #Lee el valor de la var new_C@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_C@0
jal new_ctr_C                               #
sw $v0, 164($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al CastingDispatch method5
#Evalua el parametro 0 para el CastingDispatch method5
#Evalua la Expresion para el DinamicDispatch value
#Get Self Property avar
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 160($sp)      #Guarda el valor de la propiedad avar en la variable local instance_dynamic_to_value@6
#Fin de la exprecion previa al DinamicDispatch value
lw $t0, 160($sp)      #Lee el valor de la var instance_dynamic_to_value@6
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_value@6
lw $t0, 164($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion value
jal $t3                               #
sw $v0, 156($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch method5
lw $t0, 164($sp)      #Lee el valor de la var instance_C_to_method5@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_C_to_method5@0
lw $t0, 160($sp)      #Lee el valor de la var param_0_to_method5@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_method5@0
jal C_method5                               #
move $s4, $v0      #Asigna el resultado de la funcion
lw $t0, 436($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded avar
sw $t1, 8($t0)      #Setea la propiedad avar con el valor de _
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
move $s4, $t1      #Guarda el valor de la propiedad avar en la variable local _
fin_Main_main_6:
#Fin de un If
j fin_Main_main_5                               #
then_Main_main_5:
#Then case
#Asignando un nuevo valor a la variable avar
#Evalua la Expresion para el CastingDispatch method5
#Creando instancia de tipo C
#Allocate a una class C
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 152($sp)      #Guardando en la variable local new_C@1 puntero de la instancia de la clase C
#Assignacion de la insformacion de tipo a la instancia
la $t0, C      #
move $s4, $t0      #
lw $t0, 152($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 152($sp)      #Lee el valor de la var new_C@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_C@1
jal new_ctr_C                               #
sw $v0, 148($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al CastingDispatch method5
#Evalua el parametro 0 para el CastingDispatch method5
#Evalua la Expresion para el DinamicDispatch value
#Get Self Property avar
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 144($sp)      #Guarda el valor de la propiedad avar en la variable local instance_dynamic_to_value@7
#Fin de la exprecion previa al DinamicDispatch value
lw $t0, 144($sp)      #Lee el valor de la var instance_dynamic_to_value@7
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_value@7
lw $t0, 148($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion value
jal $t3                               #
sw $v0, 140($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch method5
lw $t0, 148($sp)      #Lee el valor de la var instance_B_to_method5@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_B_to_method5@0
lw $t0, 144($sp)      #Lee el valor de la var param_0_to_method5@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_method5@1
jal B_method5                               #
move $s4, $v0      #Asigna el resultado de la funcion
lw $t0, 436($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded avar
sw $t1, 8($t0)      #Setea la propiedad avar con el valor de _
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
move $s4, $t1      #Guarda el valor de la propiedad avar en la variable local _
fin_Main_main_5:
#Fin de un If
j fin_Main_main_4                               #
then_Main_main_4:
#Then case
#Asignando un nuevo valor a la variable avar
#Evalua la Expresion para el CastingDispatch method5
#Creando instancia de tipo C
#Allocate a una class C
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 136($sp)      #Guardando en la variable local new_C@2 puntero de la instancia de la clase C
#Assignacion de la insformacion de tipo a la instancia
la $t0, C      #
move $s4, $t0      #
lw $t0, 136($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 136($sp)      #Lee el valor de la var new_C@2
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_C@2
jal new_ctr_C                               #
sw $v0, 132($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al CastingDispatch method5
#Evalua el parametro 0 para el CastingDispatch method5
#Evalua la Expresion para el DinamicDispatch value
#Get Self Property avar
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 128($sp)      #Guarda el valor de la propiedad avar en la variable local instance_dynamic_to_value@8
#Fin de la exprecion previa al DinamicDispatch value
lw $t0, 128($sp)      #Lee el valor de la var instance_dynamic_to_value@8
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_value@8
lw $t0, 132($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion value
jal $t3                               #
sw $v0, 124($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch method5
lw $t0, 132($sp)      #Lee el valor de la var instance_A_to_method5@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_A_to_method5@0
lw $t0, 128($sp)      #Lee el valor de la var param_0_to_method5@2
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_method5@2
jal A_method5                               #
move $s4, $v0      #Asigna el resultado de la funcion
lw $t0, 436($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded avar
sw $t1, 8($t0)      #Setea la propiedad avar con el valor de _
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
move $s4, $t1      #Guarda el valor de la propiedad avar en la variable local _
fin_Main_main_4:
#Fin de un If
j fin_Main_main_3                               #
then_Main_main_3:
#Then case
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Asignando un nuevo valor a la variable a_var
#Evalua la Expresion para el DinamicDispatch set_var
#Creando instancia de tipo A
#Allocate a una class A
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 120($sp)      #Guardando en la variable local new_A@3 puntero de la instancia de la clase A
#Assignacion de la insformacion de tipo a la instancia
la $t0, A      #
move $s4, $t0      #
lw $t0, 120($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 120($sp)      #Lee el valor de la var new_A@3
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_A@3
jal new_ctr_A                               #
sw $v0, 116($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch set_var
#Evalua el parametro 0 para el CastingDispatch set_var
#StaticDispatch get_int
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 440($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 48($t1)      #Buscando el metodo dinamico para la funcion get_int
jal $t3                               #
sw $v0, 112($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch set_var
lw $t0, 116($sp)      #Lee el valor de la var instance_dynamic_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_set_var@0
lw $t0, 116($sp)      #Lee el valor de la var param_0_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_set_var@0
lw $t0, 124($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion set_var
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
lw $t0, 436($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded a_var
sw $t1, 12($t0)      #Setea la propiedad a_var con el valor de _
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 12($t0)      #Lee la propiedad a_var
move $s4, $t1      #Guarda el valor de la propiedad a_var en la variable local _
#Inicio del paso 1 de una sequencia Block
#Asignando un nuevo valor a la variable avar
#Evalua la Expresion para el DinamicDispatch method4
#Creando instancia de tipo D
#Allocate a una class D
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 108($sp)      #Guardando en la variable local new_D@1 puntero de la instancia de la clase D
#Assignacion de la insformacion de tipo a la instancia
la $t0, D      #
move $s4, $t0      #
lw $t0, 108($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 108($sp)      #Lee el valor de la var new_D@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_D@1
jal new_ctr_D                               #
sw $v0, 104($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch method4
#Evalua el parametro 0 para el CastingDispatch method4
#Evalua la Expresion para el DinamicDispatch value
#Get Self Property avar
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 100($sp)      #Guarda el valor de la propiedad avar en la variable local instance_dynamic_to_value@9
#Fin de la exprecion previa al DinamicDispatch value
lw $t0, 100($sp)      #Lee el valor de la var instance_dynamic_to_value@9
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_value@9
lw $t0, 104($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion value
jal $t3                               #
sw $v0, 96($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch method4
#Evalua el parametro 1 para el CastingDispatch method4
#Evalua la Expresion para el DinamicDispatch value
#Get Self Property a_var
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 12($t0)      #Lee la propiedad a_var
sw $t1, 92($sp)      #Guarda el valor de la propiedad a_var en la variable local instance_dynamic_to_value@10
#Fin de la exprecion previa al DinamicDispatch value
lw $t0, 92($sp)      #Lee el valor de la var instance_dynamic_to_value@10
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_value@10
lw $t0, 96($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion value
jal $t3                               #
sw $v0, 88($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 1 al CastingDispatch method4
lw $t0, 104($sp)      #Lee el valor de la var instance_dynamic_to_method4@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_method4@0
lw $t0, 100($sp)      #Lee el valor de la var param_0_to_method4@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_method4@0
lw $t0, 96($sp)      #Lee el valor de la var param_1_to_method4@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_1_to_method4@0
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de D
lw $t3, 44($t1)      #Buscando el metodo dinamico para la funcion method4
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
lw $t0, 436($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded avar
sw $t1, 8($t0)      #Setea la propiedad avar con el valor de _
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
move $s4, $t1      #Guarda el valor de la propiedad avar en la variable local _
fin_Main_main_3:
#Fin de un If
j fin_Main_main_2                               #
then_Main_main_2:
#Then case
#Eval Expression To Case
#Get Self Property avar
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 84($sp)      #Guarda el valor de la propiedad avar en la variable local cond@expr@value@0
lw $t0, 84($sp)      #
lw $t1, ($t0)      #Lee la propiedad **type** de la instancia
lw $t0, 8($t1)      #Lee la propiedad **parents** de la propiedad **type**
sw $t0, 80($sp)      #
#Final Expression To Case
#Check Type To Case When Option Is C
li $s4, 9      #
lw $s6, 436($sp)      #Guarda self
lw $a0, 80($sp)      #Guarda el parametro 0 -> cond@type@0
move $a1, $s4      #Guarda el parametro 1 -> _
jal __bool__check__type__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 436($sp)      #Guarda self
jal __int__new__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 436($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, C_step_case_1     #
#Check Type To Case When Option Is A
li $s4, 7      #
lw $s6, 436($sp)      #Guarda self
lw $a0, 80($sp)      #Guarda el parametro 0 -> cond@type@0
move $a1, $s4      #Guarda el parametro 1 -> _
jal __bool__check__type__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 436($sp)      #Guarda self
jal __int__new__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 436($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, A_step_case_1     #
#Check Type To Case When Option Is Object
li $s4, 1      #
lw $s6, 436($sp)      #Guarda self
lw $a0, 80($sp)      #Guarda el parametro 0 -> cond@type@0
move $a1, $s4      #Guarda el parametro 1 -> _
jal __bool__check__type__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 436($sp)      #Guarda self
jal __int__new__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 436($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, Object_step_case_1     #
C_step_case_1:
#Assigan el valor de la expresion a la var c del case
lw $t0, 84($sp)      #
sw $t0, 76($sp)      #
#Eval Expression Of C Option
#Asignando un nuevo valor a la variable avar
#Evalua la Expresion para el DinamicDispatch method6
#Get Local Var c
lw $t0, 76($sp)      #
sw $t0, 72($sp)      #
#Fin de la exprecion previa al DinamicDispatch method6
#Evalua el parametro 0 para el CastingDispatch method6
#Evalua la Expresion para el DinamicDispatch value
#Get Local Var c
#Fin de la exprecion previa al DinamicDispatch value
lw $t0, 76($sp)      #Lee el valor de la var c
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con c
lw $t0, 80($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de C
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion value
jal $t3                               #
sw $v0, 64($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch method6
lw $t0, 72($sp)      #Lee el valor de la var instance_dynamic_to_method6@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_method6@1
lw $t0, 68($sp)      #Lee el valor de la var param_0_to_method6@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_method6@1
lw $t0, 80($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de C
lw $t3, 52($t1)      #Buscando el metodo dinamico para la funcion method6
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
lw $t0, 436($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded avar
sw $t1, 8($t0)      #Setea la propiedad avar con el valor de _
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
move $s4, $t1      #Guarda el valor de la propiedad avar en la variable local _
j case_end_1                               #
A_step_case_1:
#Assigan el valor de la expresion a la var a del case
lw $t0, 84($sp)      #
sw $t0, 232($sp)      #
#Eval Expression Of A Option
#Asignando un nuevo valor a la variable avar
#Evalua la Expresion para el DinamicDispatch method3
#Get Local Var a
lw $t0, 232($sp)      #
sw $t0, 56($sp)      #
#Fin de la exprecion previa al DinamicDispatch method3
#Evalua el parametro 0 para el CastingDispatch method3
#Evalua la Expresion para el DinamicDispatch value
#Get Local Var a
#Fin de la exprecion previa al DinamicDispatch value
lw $t0, 232($sp)      #Lee el valor de la var a
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con a
lw $t0, 236($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion value
jal $t3                               #
sw $v0, 48($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch method3
lw $t0, 56($sp)      #Lee el valor de la var instance_dynamic_to_method3@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_method3@0
lw $t0, 52($sp)      #Lee el valor de la var param_0_to_method3@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_method3@0
lw $t0, 64($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 40($t1)      #Buscando el metodo dinamico para la funcion method3
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
lw $t0, 436($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded avar
sw $t1, 8($t0)      #Setea la propiedad avar con el valor de _
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
move $s4, $t1      #Guarda el valor de la propiedad avar en la variable local _
j case_end_1                               #
Object_step_case_1:
#Assigan el valor de la expresion a la var o del case
lw $t0, 84($sp)      #
sw $t0, 44($sp)      #
#Eval Expression Of Object Option
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_74      #
move $s4, $t0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 40($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 44($sp)      #Lee el valor de la var param_0_to_out_string@12
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@12
lw $t0, 444($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 1 de una sequencia Block
#StaticDispatch abort
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 440($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 12($t1)      #Buscando el metodo dinamico para la funcion abort
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 2 de una sequencia Block
li $s4, 0      #
lw $s6, 436($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
j case_end_1                               #
case_end_1:
fin_Main_main_2:
#Fin de un If
j fin_Main_main_1                               #
then_Main_main_1:
#Then case
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Asignando un nuevo valor a la variable a_var
#Evalua la Expresion para el DinamicDispatch set_var
#Creando instancia de tipo A
#Allocate a una class A
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 36($sp)      #Guardando en la variable local new_A@4 puntero de la instancia de la clase A
#Assignacion de la insformacion de tipo a la instancia
la $t0, A      #
move $s4, $t0      #
lw $t0, 36($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 36($sp)      #Lee el valor de la var new_A@4
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_A@4
jal new_ctr_A                               #
sw $v0, 32($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch set_var
#Evalua el parametro 0 para el CastingDispatch set_var
#StaticDispatch get_int
lw $t0, 436($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 440($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 48($t1)      #Buscando el metodo dinamico para la funcion get_int
jal $t3                               #
sw $v0, 28($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch set_var
lw $t0, 32($sp)      #Lee el valor de la var instance_dynamic_to_set_var@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_set_var@1
lw $t0, 32($sp)      #Lee el valor de la var param_0_to_set_var@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_set_var@1
lw $t0, 40($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion set_var
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
lw $t0, 436($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded a_var
sw $t1, 12($t0)      #Setea la propiedad a_var con el valor de _
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 12($t0)      #Lee la propiedad a_var
move $s4, $t1      #Guarda el valor de la propiedad a_var en la variable local _
#Inicio del paso 1 de una sequencia Block
#Asignando un nuevo valor a la variable avar
#Evalua la Expresion para el DinamicDispatch method2
#Creando instancia de tipo B
#Allocate a una class B
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 24($sp)      #Guardando en la variable local new_B@0 puntero de la instancia de la clase B
#Assignacion de la insformacion de tipo a la instancia
la $t0, B      #
move $s4, $t0      #
lw $t0, 24($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 24($sp)      #Lee el valor de la var new_B@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_B@0
jal new_ctr_B                               #
sw $v0, 20($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch method2
#Evalua el parametro 0 para el CastingDispatch method2
#Evalua la Expresion para el DinamicDispatch value
#Get Self Property avar
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 16($sp)      #Guarda el valor de la propiedad avar en la variable local instance_dynamic_to_value@13
#Fin de la exprecion previa al DinamicDispatch value
lw $t0, 16($sp)      #Lee el valor de la var instance_dynamic_to_value@13
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_value@13
lw $t0, 20($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion value
jal $t3                               #
sw $v0, 12($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch method2
#Evalua el parametro 1 para el CastingDispatch method2
#Evalua la Expresion para el DinamicDispatch value
#Get Self Property a_var
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 12($t0)      #Lee la propiedad a_var
sw $t1, 8($sp)      #Guarda el valor de la propiedad a_var en la variable local instance_dynamic_to_value@14
#Fin de la exprecion previa al DinamicDispatch value
lw $t0, 8($sp)      #Lee el valor de la var instance_dynamic_to_value@14
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_value@14
lw $t0, 12($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion value
jal $t3                               #
sw $v0, 4($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 1 al CastingDispatch method2
lw $t0, 20($sp)      #Lee el valor de la var instance_dynamic_to_method2@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_method2@0
lw $t0, 16($sp)      #Lee el valor de la var param_0_to_method2@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_method2@0
lw $t0, 12($sp)      #Lee el valor de la var param_1_to_method2@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_1_to_method2@0
lw $t0, 32($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de B
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion method2
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
lw $t0, 436($sp)      #Instancia de la clase Main
move $t1, $s4      #Guarda el valor que se le asignara a la propieded avar
sw $t1, 8($t0)      #Setea la propiedad avar con el valor de _
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
move $s4, $t1      #Guarda el valor de la propiedad avar en la variable local _
fin_Main_main_1:
#Fin de un If
#Fin del cuerpo e inicio de la condicion de un While
while_cond_2:
#Get Self Property flag
lw $t0, 436($sp)      #Instancia de la clase Main
lw $t1, 16($t0)      #Lee la propiedad flag
move $s4, $t1      #Guarda el valor de la propiedad flag en la variable local _
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, while_back_2     #
#Fin de la condicion de un While
lw $t0, 436($sp)      #
move $s4, $t0      #
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 440     #
jr $ra                               #

new_ctr_IO:     #
#Parametro self en stackpoiner + 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion new_ctr_IO
lw $t0, 4($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
jal new_ctr_Object                               #
lw $v0, 4($sp)      #Return self
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 8     #
jr $ra                               #

new_ctr_A:     #
#Parametro self en stackpoiner + 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion new_ctr_A
lw $t0, 4($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
jal new_ctr_Object                               #
#Assignando el resultado de la expression al atributo var de la clase A
li $s4, 0      #
lw $s6, 4($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
lw $t0, 4($sp)      #Instancia de la clase A
move $t1, $s4      #Guarda el valor que se le asignara a la propieded var
sw $t1, 4($t0)      #Setea la propiedad var con el valor de _
#Fin De la Asignacion
lw $v0, 4($sp)      #Return self
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 8     #
jr $ra                               #

IO_out_string:     #
#Parametro self en stackpoiner + 4
#Parametro string en stackpoiner + 0
addi $sp, $sp, -4     #Push local var $ra stackpointer -4
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion IO_out_string
lw $s6, 8($sp)      #Guarda self
lw $a0, 4($sp)      #Guarda el parametro 0 -> string
jal __str__print__                               #
lw $ra, 0($sp)      #
addi $sp, $sp, 12     #
jr $ra                               #

Main_print:     #
#Parametro self en stackpoiner + 36
#Parametro var@0 en stackpoiner + 32
addi $sp, $sp, -4     #Push local var z stackpointer 28
addi $sp, $sp, -4     #Push local var new_A2I@0 stackpointer 24
addi $sp, $sp, -4     #Push local var instance_dynamic_to_i2a@0 stackpointer 20
addi $sp, $sp, -4     #Push local var instance_dynamic_to_value@0 stackpointer 16
addi $sp, $sp, -4     #Push local var param_0_to_i2a@0 stackpointer 12
addi $sp, $sp, -4     #Push local var param_0_to_out_string@0 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_out_string@1 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion Main_print
#Eval Expression to Let z
#Creando instancia de tipo A2I
#Allocate a una class A2I
#atributo type_name en puntero + 0
li $a0, 4      #
li $v0, 9      #
syscall
sw $v0, 24($sp)      #Guardando en la variable local new_A2I@0 puntero de la instancia de la clase A2I
#Assignacion de la insformacion de tipo a la instancia
la $t0, A2I      #
move $s4, $t0      #
lw $t0, 24($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 24($sp)      #Lee el valor de la var new_A2I@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_A2I@0
jal new_ctr_A2I                               #
sw $v0, 28($sp)      #Asigna el resultado de la funcion
#Fin de la asignacion Let z
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
#Evalua la Expresion para el DinamicDispatch i2a
#Get Local Var z
lw $t0, 28($sp)      #
sw $t0, 20($sp)      #
#Fin de la exprecion previa al DinamicDispatch i2a
#Evalua el parametro 0 para el CastingDispatch i2a
#Evalua la Expresion para el DinamicDispatch value
#Get Local Var var
#Fin de la exprecion previa al DinamicDispatch value
lw $t0, 32($sp)      #Lee el valor de la var var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con var@0
lw $t0, 36($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion value
jal $t3                               #
sw $v0, 12($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch i2a
lw $t0, 20($sp)      #Lee el valor de la var instance_dynamic_to_i2a@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_i2a@0
lw $t0, 16($sp)      #Lee el valor de la var param_0_to_i2a@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_i2a@0
lw $t0, 28($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A2I
lw $t3, 40($t1)      #Buscando el metodo dinamico para la funcion i2a
jal $t3                               #
sw $v0, 8($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 36($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 12($sp)      #Lee el valor de la var param_0_to_out_string@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@0
lw $t0, 44($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 1 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_52      #
move $s4, $t0      #
lw $s6, 36($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 4($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 36($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_out_string@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@1
lw $t0, 44($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 40     #
jr $ra                               #

A_value:     #
#Parametro self en stackpoiner + 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion A_value
#Get Self Property var
lw $t0, 4($sp)      #Instancia de la clase A
lw $t1, 4($t0)      #Lee la propiedad var
move $s4, $t1      #Guarda el valor de la propiedad var en la variable local _
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 8     #
jr $ra                               #

Main_is_even:     #
#Parametro self en stackpoiner + 52
#Parametro num@0 en stackpoiner + 48
addi $sp, $sp, -4     #Push local var x stackpointer 44
addi $sp, $sp, -4     #Push local var less@_a@0 stackpointer 40
addi $sp, $sp, -4     #Push local var less@_b@0 stackpointer 36
addi $sp, $sp, -4     #Push local var int_eq@_a@0 stackpointer 32
addi $sp, $sp, -4     #Push local var int_eq@_b@0 stackpointer 28
addi $sp, $sp, -4     #Push local var int_eq@_a@1 stackpointer 24
addi $sp, $sp, -4     #Push local var int_eq@_b@1 stackpointer 20
addi $sp, $sp, -4     #Push local var rest@_a@0 stackpointer 16
addi $sp, $sp, -4     #Push local var rest@_b@0 stackpointer 12
addi $sp, $sp, -4     #Push local var param_0_to_is_even@0 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_is_even@1 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion Main_is_even
#Eval Expression to Let x
#Get Local Var num
lw $t0, 48($sp)      #
sw $t0, 44($sp)      #
#Fin de la asignacion Let x
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion less
#Get Local Var x
lw $t0, 44($sp)      #
sw $t0, 40($sp)      #
#Resolucion del operado izquierdo de una operacion less
#Evaluando el operado derecho de una operacion less
li $s4, 0      #
lw $s6, 52($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 36($sp)      #
#Resolucion del operado derecha de una operacion less
lw $s6, 52($sp)      #Guarda self
lw $a0, 40($sp)      #Guarda el parametro 0 -> less@_a@0
lw $a1, 36($sp)      #Guarda el parametro 1 -> less@_b@0
jal __int__le__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 52($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_Main_is_even_0     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
li $s4, 0      #
lw $s6, 52($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 32($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
#Get Local Var x
lw $t0, 44($sp)      #
sw $t0, 28($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 52($sp)      #Guarda self
lw $a0, 32($sp)      #Guarda el parametro 0 -> int_eq@_a@0
lw $a1, 28($sp)      #Guarda el parametro 1 -> int_eq@_b@0
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 52($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_Main_is_even_1     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
li $s4, 1      #
lw $s6, 52($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 24($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
#Get Local Var x
lw $t0, 44($sp)      #
sw $t0, 20($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 52($sp)      #Guarda self
lw $a0, 24($sp)      #Guarda el parametro 0 -> int_eq@_a@1
lw $a1, 20($sp)      #Guarda el parametro 1 -> int_eq@_b@1
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 52($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_Main_is_even_2     #
#Else case
#StaticDispatch is_even
#Evalua el parametro 0 para el CastingDispatch is_even
#Evaluando el operado izquierdo de una operacion rest
#Get Local Var x
lw $t0, 44($sp)      #
sw $t0, 16($sp)      #
#Resolucion del operado izquierdo de una operacion rest
#Evaluando el operado derecho de una operacion rest
li $s4, 2      #
lw $s6, 52($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 12($sp)      #
#Resolucion del operado derecha de una operacion rest
lw $s6, 52($sp)      #Guarda self
lw $a0, 16($sp)      #Guarda el parametro 0 -> rest@_a@0
lw $a1, 12($sp)      #Guarda el parametro 1 -> rest@_b@0
jal __int__sub__                               #
sw $v0, 8($sp)      #
#Fin del paramentro 0 al CastingDispatch is_even
lw $t0, 52($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 12($sp)      #Lee el valor de la var param_0_to_is_even@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_is_even@0
lw $t0, 60($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 52($t1)      #Buscando el metodo dinamico para la funcion is_even
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
j fin_Main_is_even_2                               #
then_Main_is_even_2:
#Then case
li $s4, 0      #
lw $s6, 52($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
lw $s6, 52($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __bool__new__                               #
move $s4, $v0      #
fin_Main_is_even_2:
#Fin de un If
j fin_Main_is_even_1                               #
then_Main_is_even_1:
#Then case
li $s4, 1      #
lw $s6, 52($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
lw $s6, 52($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __bool__new__                               #
move $s4, $v0      #
fin_Main_is_even_1:
#Fin de un If
j fin_Main_is_even_0                               #
then_Main_is_even_0:
#Then case
#StaticDispatch is_even
#Evalua el parametro 0 para el CastingDispatch is_even
#Evaluando la expression de una operacion unaria
#Get Local Var x
lw $t0, 44($sp)      #
move $s4, $t0      #
#FIN expression de una operacion unaria
lw $s6, 52($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__complement__                               #
sw $v0, 4($sp)      #
#Fin del paramentro 0 al CastingDispatch is_even
lw $t0, 52($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_is_even@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_is_even@1
lw $t0, 60($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 52($t1)      #Buscando el metodo dinamico para la funcion is_even
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
fin_Main_is_even_0:
#Fin de un If
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 56     #
jr $ra                               #

Main_class_type:     #
#Parametro self en stackpoiner + 64
#Parametro var@0 en stackpoiner + 60
addi $sp, $sp, -4     #Push local var cond@expr@value@0 stackpointer 56
addi $sp, $sp, -4     #Push local var cond@type@0 stackpointer 52
addi $sp, $sp, -4     #Push local var e stackpointer 48
addi $sp, $sp, -4     #Push local var param_0_to_out_string@0 stackpointer 44
addi $sp, $sp, -4     #Push local var d stackpointer 40
addi $sp, $sp, -4     #Push local var param_0_to_out_string@1 stackpointer 36
addi $sp, $sp, -4     #Push local var c stackpointer 32
addi $sp, $sp, -4     #Push local var param_0_to_out_string@2 stackpointer 28
addi $sp, $sp, -4     #Push local var b stackpointer 24
addi $sp, $sp, -4     #Push local var param_0_to_out_string@3 stackpointer 20
addi $sp, $sp, -4     #Push local var a stackpointer 16
addi $sp, $sp, -4     #Push local var param_0_to_out_string@4 stackpointer 12
addi $sp, $sp, -4     #Push local var o stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_out_string@5 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion Main_class_type
#Eval Expression To Case
#Get Local Var var
lw $t0, 60($sp)      #
sw $t0, 56($sp)      #
lw $t0, 56($sp)      #
lw $t1, ($t0)      #Lee la propiedad **type** de la instancia
lw $t0, 8($t1)      #Lee la propiedad **parents** de la propiedad **type**
sw $t0, 52($sp)      #
#Final Expression To Case
#Check Type To Case When Option Is E
li $s4, 11      #
lw $s6, 64($sp)      #Guarda self
lw $a0, 52($sp)      #Guarda el parametro 0 -> cond@type@0
move $a1, $s4      #Guarda el parametro 1 -> _
jal __bool__check__type__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 64($sp)      #Guarda self
jal __int__new__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 64($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, E_step_case_0     #
#Check Type To Case When Option Is D
li $s4, 10      #
lw $s6, 64($sp)      #Guarda self
lw $a0, 52($sp)      #Guarda el parametro 0 -> cond@type@0
move $a1, $s4      #Guarda el parametro 1 -> _
jal __bool__check__type__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 64($sp)      #Guarda self
jal __int__new__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 64($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, D_step_case_0     #
#Check Type To Case When Option Is C
li $s4, 9      #
lw $s6, 64($sp)      #Guarda self
lw $a0, 52($sp)      #Guarda el parametro 0 -> cond@type@0
move $a1, $s4      #Guarda el parametro 1 -> _
jal __bool__check__type__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 64($sp)      #Guarda self
jal __int__new__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 64($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, C_step_case_0     #
#Check Type To Case When Option Is B
li $s4, 8      #
lw $s6, 64($sp)      #Guarda self
lw $a0, 52($sp)      #Guarda el parametro 0 -> cond@type@0
move $a1, $s4      #Guarda el parametro 1 -> _
jal __bool__check__type__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 64($sp)      #Guarda self
jal __int__new__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 64($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, B_step_case_0     #
#Check Type To Case When Option Is A
li $s4, 7      #
lw $s6, 64($sp)      #Guarda self
lw $a0, 52($sp)      #Guarda el parametro 0 -> cond@type@0
move $a1, $s4      #Guarda el parametro 1 -> _
jal __bool__check__type__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 64($sp)      #Guarda self
jal __int__new__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 64($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, A_step_case_0     #
#Check Type To Case When Option Is Object
li $s4, 1      #
lw $s6, 64($sp)      #Guarda self
lw $a0, 52($sp)      #Guarda el parametro 0 -> cond@type@0
move $a1, $s4      #Guarda el parametro 1 -> _
jal __bool__check__type__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 64($sp)      #Guarda self
jal __int__new__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 64($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, Object_step_case_0     #
E_step_case_0:
#Assigan el valor de la expresion a la var e del case
lw $t0, 56($sp)      #
sw $t0, 48($sp)      #
#Eval Expression Of E Option
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_46      #
move $s4, $t0      #
lw $s6, 64($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 44($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 64($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 48($sp)      #Lee el valor de la var param_0_to_out_string@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@0
lw $t0, 72($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
j case_end_0                               #
D_step_case_0:
#Assigan el valor de la expresion a la var d del case
lw $t0, 56($sp)      #
sw $t0, 40($sp)      #
#Eval Expression Of D Option
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_47      #
move $s4, $t0      #
lw $s6, 64($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 36($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 64($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 40($sp)      #Lee el valor de la var param_0_to_out_string@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@1
lw $t0, 72($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
j case_end_0                               #
C_step_case_0:
#Assigan el valor de la expresion a la var c del case
lw $t0, 56($sp)      #
sw $t0, 32($sp)      #
#Eval Expression Of C Option
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_48      #
move $s4, $t0      #
lw $s6, 64($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 28($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 64($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 32($sp)      #Lee el valor de la var param_0_to_out_string@2
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@2
lw $t0, 72($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
j case_end_0                               #
B_step_case_0:
#Assigan el valor de la expresion a la var b del case
lw $t0, 56($sp)      #
sw $t0, 24($sp)      #
#Eval Expression Of B Option
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_49      #
move $s4, $t0      #
lw $s6, 64($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 20($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 64($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 24($sp)      #Lee el valor de la var param_0_to_out_string@3
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@3
lw $t0, 72($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
j case_end_0                               #
A_step_case_0:
#Assigan el valor de la expresion a la var a del case
lw $t0, 56($sp)      #
sw $t0, 16($sp)      #
#Eval Expression Of A Option
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_50      #
move $s4, $t0      #
lw $s6, 64($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 12($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 64($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 16($sp)      #Lee el valor de la var param_0_to_out_string@4
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@4
lw $t0, 72($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
j case_end_0                               #
Object_step_case_0:
#Assigan el valor de la expresion a la var o del case
lw $t0, 56($sp)      #
sw $t0, 8($sp)      #
#Eval Expression Of Object Option
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_51      #
move $s4, $t0      #
lw $s6, 64($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 4($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 64($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_out_string@5
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@5
lw $t0, 72($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
j case_end_0                               #
case_end_0:
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 68     #
jr $ra                               #

Main_menu:     #
#Parametro self en stackpoiner + 108
addi $sp, $sp, -4     #Push local var param_0_to_out_string@0 stackpointer 104
addi $sp, $sp, -4     #Push local var param_0_to_print@0 stackpointer 100
addi $sp, $sp, -4     #Push local var param_0_to_out_string@1 stackpointer 96
addi $sp, $sp, -4     #Push local var param_0_to_out_string@2 stackpointer 92
addi $sp, $sp, -4     #Push local var param_0_to_print@1 stackpointer 88
addi $sp, $sp, -4     #Push local var param_0_to_out_string@3 stackpointer 84
addi $sp, $sp, -4     #Push local var param_0_to_out_string@4 stackpointer 80
addi $sp, $sp, -4     #Push local var param_0_to_print@2 stackpointer 76
addi $sp, $sp, -4     #Push local var param_0_to_out_string@5 stackpointer 72
addi $sp, $sp, -4     #Push local var param_0_to_out_string@6 stackpointer 68
addi $sp, $sp, -4     #Push local var param_0_to_print@3 stackpointer 64
addi $sp, $sp, -4     #Push local var param_0_to_out_string@7 stackpointer 60
addi $sp, $sp, -4     #Push local var param_0_to_out_string@8 stackpointer 56
addi $sp, $sp, -4     #Push local var param_0_to_print@4 stackpointer 52
addi $sp, $sp, -4     #Push local var param_0_to_out_string@9 stackpointer 48
addi $sp, $sp, -4     #Push local var param_0_to_out_string@10 stackpointer 44
addi $sp, $sp, -4     #Push local var param_0_to_print@5 stackpointer 40
addi $sp, $sp, -4     #Push local var param_0_to_out_string@11 stackpointer 36
addi $sp, $sp, -4     #Push local var param_0_to_out_string@12 stackpointer 32
addi $sp, $sp, -4     #Push local var param_0_to_print@6 stackpointer 28
addi $sp, $sp, -4     #Push local var param_0_to_out_string@13 stackpointer 24
addi $sp, $sp, -4     #Push local var param_0_to_out_string@14 stackpointer 20
addi $sp, $sp, -4     #Push local var param_0_to_print@7 stackpointer 16
addi $sp, $sp, -4     #Push local var param_0_to_out_string@15 stackpointer 12
addi $sp, $sp, -4     #Push local var param_0_to_out_string@16 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_out_string@17 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion Main_menu
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_26      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 104($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 108($sp)      #Lee el valor de la var param_0_to_out_string@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@0
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 1 de una sequencia Block
#StaticDispatch print
#Evalua el parametro 0 para el CastingDispatch print
#Get Self Property avar
lw $t0, 108($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 100($sp)      #Guarda el valor de la propiedad avar en la variable local param_0_to_print@0
#Fin del paramentro 0 al CastingDispatch print
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 104($sp)      #Lee el valor de la var param_0_to_print@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_print@0
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 60($t1)      #Buscando el metodo dinamico para la funcion print
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 2 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_27      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 96($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 100($sp)      #Lee el valor de la var param_0_to_out_string@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@1
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 3 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_28      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 92($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 96($sp)      #Lee el valor de la var param_0_to_out_string@2
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@2
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 4 de una sequencia Block
#StaticDispatch print
#Evalua el parametro 0 para el CastingDispatch print
#Get Self Property avar
lw $t0, 108($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 88($sp)      #Guarda el valor de la propiedad avar en la variable local param_0_to_print@1
#Fin del paramentro 0 al CastingDispatch print
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 92($sp)      #Lee el valor de la var param_0_to_print@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_print@1
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 60($t1)      #Buscando el metodo dinamico para la funcion print
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 5 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_29      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 84($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 88($sp)      #Lee el valor de la var param_0_to_out_string@3
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@3
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 6 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_30      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 80($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 84($sp)      #Lee el valor de la var param_0_to_out_string@4
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@4
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 7 de una sequencia Block
#StaticDispatch print
#Evalua el parametro 0 para el CastingDispatch print
#Get Self Property avar
lw $t0, 108($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 76($sp)      #Guarda el valor de la propiedad avar en la variable local param_0_to_print@2
#Fin del paramentro 0 al CastingDispatch print
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 80($sp)      #Lee el valor de la var param_0_to_print@2
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_print@2
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 60($t1)      #Buscando el metodo dinamico para la funcion print
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 8 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_31      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 72($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 76($sp)      #Lee el valor de la var param_0_to_out_string@5
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@5
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 9 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_32      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 68($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 72($sp)      #Lee el valor de la var param_0_to_out_string@6
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@6
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 10 de una sequencia Block
#StaticDispatch print
#Evalua el parametro 0 para el CastingDispatch print
#Get Self Property avar
lw $t0, 108($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 64($sp)      #Guarda el valor de la propiedad avar en la variable local param_0_to_print@3
#Fin del paramentro 0 al CastingDispatch print
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 68($sp)      #Lee el valor de la var param_0_to_print@3
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_print@3
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 60($t1)      #Buscando el metodo dinamico para la funcion print
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 11 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_33      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 60($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 64($sp)      #Lee el valor de la var param_0_to_out_string@7
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@7
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 12 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_34      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 56($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 60($sp)      #Lee el valor de la var param_0_to_out_string@8
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@8
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 13 de una sequencia Block
#StaticDispatch print
#Evalua el parametro 0 para el CastingDispatch print
#Get Self Property avar
lw $t0, 108($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 52($sp)      #Guarda el valor de la propiedad avar en la variable local param_0_to_print@4
#Fin del paramentro 0 al CastingDispatch print
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 56($sp)      #Lee el valor de la var param_0_to_print@4
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_print@4
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 60($t1)      #Buscando el metodo dinamico para la funcion print
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 14 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_35      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 48($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 52($sp)      #Lee el valor de la var param_0_to_out_string@9
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@9
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 15 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_36      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 44($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 48($sp)      #Lee el valor de la var param_0_to_out_string@10
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@10
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 16 de una sequencia Block
#StaticDispatch print
#Evalua el parametro 0 para el CastingDispatch print
#Get Self Property avar
lw $t0, 108($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 40($sp)      #Guarda el valor de la propiedad avar en la variable local param_0_to_print@5
#Fin del paramentro 0 al CastingDispatch print
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 44($sp)      #Lee el valor de la var param_0_to_print@5
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_print@5
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 60($t1)      #Buscando el metodo dinamico para la funcion print
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 17 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_37      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 36($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 40($sp)      #Lee el valor de la var param_0_to_out_string@11
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@11
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 18 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_38      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 32($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 36($sp)      #Lee el valor de la var param_0_to_out_string@12
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@12
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 19 de una sequencia Block
#StaticDispatch print
#Evalua el parametro 0 para el CastingDispatch print
#Get Self Property avar
lw $t0, 108($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 28($sp)      #Guarda el valor de la propiedad avar en la variable local param_0_to_print@6
#Fin del paramentro 0 al CastingDispatch print
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 32($sp)      #Lee el valor de la var param_0_to_print@6
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_print@6
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 60($t1)      #Buscando el metodo dinamico para la funcion print
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 20 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_39      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 24($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 28($sp)      #Lee el valor de la var param_0_to_out_string@13
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@13
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 21 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_40      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 20($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 24($sp)      #Lee el valor de la var param_0_to_out_string@14
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@14
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 22 de una sequencia Block
#StaticDispatch print
#Evalua el parametro 0 para el CastingDispatch print
#Get Self Property avar
lw $t0, 108($sp)      #Instancia de la clase Main
lw $t1, 8($t0)      #Lee la propiedad avar
sw $t1, 16($sp)      #Guarda el valor de la propiedad avar en la variable local param_0_to_print@7
#Fin del paramentro 0 al CastingDispatch print
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 20($sp)      #Lee el valor de la var param_0_to_print@7
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_print@7
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 60($t1)      #Buscando el metodo dinamico para la funcion print
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 23 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_41      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 12($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 16($sp)      #Lee el valor de la var param_0_to_out_string@15
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@15
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 24 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_42      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 8($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 12($sp)      #Lee el valor de la var param_0_to_out_string@16
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@16
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 25 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_43      #
move $s4, $t0      #
lw $s6, 108($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 4($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_out_string@17
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@17
lw $t0, 116($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 26 de una sequencia Block
#StaticDispatch in_string
lw $t0, 108($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 112($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion in_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 112     #
jr $ra                               #

A_method1:     #
#Parametro self en stackpoiner + 8
#Parametro num@0 en stackpoiner + 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion A_method1
#Get Local Var self
lw $t0, 8($sp)      #
move $s4, $t0      #
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 12     #
jr $ra                               #

new_ctr_E:     #
#Parametro self en stackpoiner + 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion new_ctr_E
lw $t0, 4($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
jal new_ctr_D                               #
lw $v0, 4($sp)      #Return self
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 8     #
jr $ra                               #

C_method6:     #
#Parametro self en stackpoiner + 24
#Parametro num@0 en stackpoiner + 20
addi $sp, $sp, -4     #Push local var x stackpointer 16
addi $sp, $sp, -4     #Push local var new_A@0 stackpointer 12
addi $sp, $sp, -4     #Push local var instance_dynamic_to_set_var@0 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_set_var@0 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion C_method6
li $s4, 0      #
lw $s6, 24($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 16($sp)      #
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Asignando un nuevo valor a la variable x
#Evaluando la expression de una operacion unaria
#Get Local Var num
lw $t0, 20($sp)      #
move $s4, $t0      #
#FIN expression de una operacion unaria
lw $s6, 24($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__complement__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 16($sp)      #
lw $t0, 16($sp)      #
move $s4, $t0      #
#Inicio del paso 1 de una sequencia Block
#Evalua la Expresion para el DinamicDispatch set_var
#Creando instancia de tipo A
#Allocate a una class A
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 12($sp)      #Guardando en la variable local new_A@0 puntero de la instancia de la clase A
#Assignacion de la insformacion de tipo a la instancia
la $t0, A      #
move $s4, $t0      #
lw $t0, 12($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 12($sp)      #Lee el valor de la var new_A@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_A@0
jal new_ctr_A                               #
sw $v0, 8($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch set_var
#Evalua el parametro 0 para el CastingDispatch set_var
#Get Local Var x
lw $t0, 16($sp)      #
sw $t0, 4($sp)      #
#Fin del paramentro 0 al CastingDispatch set_var
lw $t0, 8($sp)      #Lee el valor de la var instance_dynamic_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_set_var@0
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_set_var@0
lw $t0, 16($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion set_var
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 28     #
jr $ra                               #

E_method6:     #
#Parametro self en stackpoiner + 32
#Parametro num@0 en stackpoiner + 28
addi $sp, $sp, -4     #Push local var x stackpointer 24
addi $sp, $sp, -4     #Push local var div@_a@0 stackpointer 20
addi $sp, $sp, -4     #Push local var div@_b@0 stackpointer 16
addi $sp, $sp, -4     #Push local var new_A@0 stackpointer 12
addi $sp, $sp, -4     #Push local var instance_dynamic_to_set_var@0 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_set_var@0 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion E_method6
li $s4, 0      #
lw $s6, 32($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 24($sp)      #
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Asignando un nuevo valor a la variable x
#Evaluando el operado izquierdo de una operacion div
#Get Local Var num
lw $t0, 28($sp)      #
sw $t0, 20($sp)      #
#Resolucion del operado izquierdo de una operacion div
#Evaluando el operado derecho de una operacion div
li $s4, 8      #
lw $s6, 32($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 16($sp)      #
#Resolucion del operado derecha de una operacion div
lw $s6, 32($sp)      #Guarda self
lw $a0, 20($sp)      #Guarda el parametro 0 -> div@_a@0
lw $a1, 16($sp)      #Guarda el parametro 1 -> div@_b@0
jal __int__div__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 24($sp)      #
lw $t0, 24($sp)      #
move $s4, $t0      #
#Inicio del paso 1 de una sequencia Block
#Evalua la Expresion para el DinamicDispatch set_var
#Creando instancia de tipo A
#Allocate a una class A
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 12($sp)      #Guardando en la variable local new_A@0 puntero de la instancia de la clase A
#Assignacion de la insformacion de tipo a la instancia
la $t0, A      #
move $s4, $t0      #
lw $t0, 12($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 12($sp)      #Lee el valor de la var new_A@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_A@0
jal new_ctr_A                               #
sw $v0, 8($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch set_var
#Evalua el parametro 0 para el CastingDispatch set_var
#Get Local Var x
lw $t0, 24($sp)      #
sw $t0, 4($sp)      #
#Fin del paramentro 0 al CastingDispatch set_var
lw $t0, 8($sp)      #Lee el valor de la var instance_dynamic_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_set_var@0
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_set_var@0
lw $t0, 16($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion set_var
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 36     #
jr $ra                               #

new_ctr_A2I:     #
#Parametro self en stackpoiner + 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion new_ctr_A2I
lw $t0, 4($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
jal new_ctr_Object                               #
lw $v0, 4($sp)      #Return self
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 8     #
jr $ra                               #

A2I_i2a:     #
#Parametro self en stackpoiner + 48
#Parametro i@0 en stackpoiner + 44
addi $sp, $sp, -4     #Push local var int_eq@_a@0 stackpointer 40
addi $sp, $sp, -4     #Push local var int_eq@_b@0 stackpointer 36
addi $sp, $sp, -4     #Push local var less@_a@0 stackpointer 32
addi $sp, $sp, -4     #Push local var less@_b@0 stackpointer 28
addi $sp, $sp, -4     #Push local var instance_dynamic_to_concat@0 stackpointer 24
addi $sp, $sp, -4     #Push local var factor@_a@0 stackpointer 20
addi $sp, $sp, -4     #Push local var factor@_b@0 stackpointer 16
addi $sp, $sp, -4     #Push local var param_0_to_i2a_aux@0 stackpointer 12
addi $sp, $sp, -4     #Push local var param_0_to_concat@0 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_i2a_aux@1 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion A2I_i2a
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
#Get Local Var i
lw $t0, 44($sp)      #
sw $t0, 40($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
li $s4, 0      #
lw $s6, 48($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 36($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 48($sp)      #Guarda self
lw $a0, 40($sp)      #Guarda el parametro 0 -> int_eq@_a@0
lw $a1, 36($sp)      #Guarda el parametro 1 -> int_eq@_b@0
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 48($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_i2a_0     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion less
li $s4, 0      #
lw $s6, 48($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 32($sp)      #
#Resolucion del operado izquierdo de una operacion less
#Evaluando el operado derecho de una operacion less
#Get Local Var i
lw $t0, 44($sp)      #
sw $t0, 28($sp)      #
#Resolucion del operado derecha de una operacion less
lw $s6, 48($sp)      #Guarda self
lw $a0, 32($sp)      #Guarda el parametro 0 -> less@_a@0
lw $a1, 28($sp)      #Guarda el parametro 1 -> less@_b@0
jal __int__le__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 48($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_i2a_1     #
#Else case
#Evalua la Expresion para el DinamicDispatch concat
la $t0, string_23      #
move $s4, $t0      #
lw $s6, 48($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 24($sp)      #
#Fin de la exprecion previa al DinamicDispatch concat
#Evalua el parametro 0 para el CastingDispatch concat
#StaticDispatch i2a_aux
#Evalua el parametro 0 para el CastingDispatch i2a_aux
#Evaluando el operado izquierdo de una operacion factor
#Get Local Var i
lw $t0, 44($sp)      #
sw $t0, 20($sp)      #
#Resolucion del operado izquierdo de una operacion factor
#Evaluando el operado derecho de una operacion factor
#Evaluando la expression de una operacion unaria
li $s4, 1      #
lw $s6, 48($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
#FIN expression de una operacion unaria
lw $s6, 48($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__complement__                               #
sw $v0, 16($sp)      #
#Resolucion del operado derecha de una operacion factor
lw $s6, 48($sp)      #Guarda self
lw $a0, 20($sp)      #Guarda el parametro 0 -> factor@_a@0
lw $a1, 16($sp)      #Guarda el parametro 1 -> factor@_b@0
jal __int__mul__                               #
sw $v0, 12($sp)      #
#Fin del paramentro 0 al CastingDispatch i2a_aux
lw $t0, 48($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 16($sp)      #Lee el valor de la var param_0_to_i2a_aux@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_i2a_aux@0
lw $t0, 56($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A2I
lw $t3, 44($t1)      #Buscando el metodo dinamico para la funcion i2a_aux
jal $t3                               #
sw $v0, 8($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch concat
lw $t0, 24($sp)      #Lee el valor de la var instance_dynamic_to_concat@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_concat@0
lw $t0, 12($sp)      #Lee el valor de la var param_0_to_concat@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_concat@0
lw $t0, 32($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de String
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion concat
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
j fin_A2I_i2a_1                               #
then_A2I_i2a_1:
#Then case
#StaticDispatch i2a_aux
#Evalua el parametro 0 para el CastingDispatch i2a_aux
#Get Local Var i
lw $t0, 44($sp)      #
sw $t0, 4($sp)      #
#Fin del paramentro 0 al CastingDispatch i2a_aux
lw $t0, 48($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_i2a_aux@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_i2a_aux@1
lw $t0, 56($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A2I
lw $t3, 44($t1)      #Buscando el metodo dinamico para la funcion i2a_aux
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
fin_A2I_i2a_1:
#Fin de un If
j fin_A2I_i2a_0                               #
then_A2I_i2a_0:
#Then case
la $t0, string_24      #
move $s4, $t0      #
lw $s6, 48($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
move $s4, $v0      #
fin_A2I_i2a_0:
#Fin de un If
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 52     #
jr $ra                               #

A2I_i2a_aux:     #
#Parametro self en stackpoiner + 60
#Parametro i@0 en stackpoiner + 56
addi $sp, $sp, -4     #Push local var int_eq@_a@0 stackpointer 52
addi $sp, $sp, -4     #Push local var int_eq@_b@0 stackpointer 48
addi $sp, $sp, -4     #Push local var next stackpointer 44
addi $sp, $sp, -4     #Push local var div@_a@0 stackpointer 40
addi $sp, $sp, -4     #Push local var div@_b@0 stackpointer 36
addi $sp, $sp, -4     #Push local var param_0_to_i2a_aux@0 stackpointer 32
addi $sp, $sp, -4     #Push local var instance_dynamic_to_concat@0 stackpointer 28
addi $sp, $sp, -4     #Push local var rest@_a@0 stackpointer 24
addi $sp, $sp, -4     #Push local var rest@_b@0 stackpointer 20
addi $sp, $sp, -4     #Push local var factor@_a@0 stackpointer 16
addi $sp, $sp, -4     #Push local var factor@_b@0 stackpointer 12
addi $sp, $sp, -4     #Push local var param_0_to_i2c@0 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_concat@0 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion A2I_i2a_aux
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
#Get Local Var i
lw $t0, 56($sp)      #
sw $t0, 52($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
li $s4, 0      #
lw $s6, 60($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 48($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 60($sp)      #Guarda self
lw $a0, 52($sp)      #Guarda el parametro 0 -> int_eq@_a@0
lw $a1, 48($sp)      #Guarda el parametro 1 -> int_eq@_b@0
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 60($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_i2a_aux_0     #
#Else case
#Eval Expression to Let next
#Evaluando el operado izquierdo de una operacion div
#Get Local Var i
lw $t0, 56($sp)      #
sw $t0, 40($sp)      #
#Resolucion del operado izquierdo de una operacion div
#Evaluando el operado derecho de una operacion div
li $s4, 10      #
lw $s6, 60($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 36($sp)      #
#Resolucion del operado derecha de una operacion div
lw $s6, 60($sp)      #Guarda self
lw $a0, 40($sp)      #Guarda el parametro 0 -> div@_a@0
lw $a1, 36($sp)      #Guarda el parametro 1 -> div@_b@0
jal __int__div__                               #
sw $v0, 44($sp)      #
#Fin de la asignacion Let next
#Evalua la Expresion para el DinamicDispatch concat
#StaticDispatch i2a_aux
#Evalua el parametro 0 para el CastingDispatch i2a_aux
#Get Local Var next
lw $t0, 44($sp)      #
sw $t0, 32($sp)      #
#Fin del paramentro 0 al CastingDispatch i2a_aux
lw $t0, 60($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 36($sp)      #Lee el valor de la var param_0_to_i2a_aux@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_i2a_aux@0
lw $t0, 68($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A2I
lw $t3, 44($t1)      #Buscando el metodo dinamico para la funcion i2a_aux
jal $t3                               #
sw $v0, 28($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch concat
#Evalua el parametro 0 para el CastingDispatch concat
#StaticDispatch i2c
#Evalua el parametro 0 para el CastingDispatch i2c
#Evaluando el operado izquierdo de una operacion rest
#Get Local Var i
lw $t0, 56($sp)      #
sw $t0, 24($sp)      #
#Resolucion del operado izquierdo de una operacion rest
#Evaluando el operado derecho de una operacion rest
#Evaluando el operado izquierdo de una operacion factor
#Get Local Var next
lw $t0, 44($sp)      #
sw $t0, 16($sp)      #
#Resolucion del operado izquierdo de una operacion factor
#Evaluando el operado derecho de una operacion factor
li $s4, 10      #
lw $s6, 60($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 12($sp)      #
#Resolucion del operado derecha de una operacion factor
lw $s6, 60($sp)      #Guarda self
lw $a0, 16($sp)      #Guarda el parametro 0 -> factor@_a@0
lw $a1, 12($sp)      #Guarda el parametro 1 -> factor@_b@0
jal __int__mul__                               #
sw $v0, 20($sp)      #
#Resolucion del operado derecha de una operacion rest
lw $s6, 60($sp)      #Guarda self
lw $a0, 24($sp)      #Guarda el parametro 0 -> rest@_a@0
lw $a1, 20($sp)      #Guarda el parametro 1 -> rest@_b@0
jal __int__sub__                               #
sw $v0, 8($sp)      #
#Fin del paramentro 0 al CastingDispatch i2c
lw $t0, 60($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 12($sp)      #Lee el valor de la var param_0_to_i2c@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_i2c@0
lw $t0, 68($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A2I
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion i2c
jal $t3                               #
sw $v0, 4($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch concat
lw $t0, 28($sp)      #Lee el valor de la var instance_dynamic_to_concat@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_concat@0
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_concat@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_concat@0
lw $t0, 36($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de String
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion concat
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
j fin_A2I_i2a_aux_0                               #
then_A2I_i2a_aux_0:
#Then case
la $t0, string_25      #
move $s4, $t0      #
lw $s6, 60($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
move $s4, $v0      #
fin_A2I_i2a_aux_0:
#Fin de un If
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 64     #
jr $ra                               #

new_ctr_D:     #
#Parametro self en stackpoiner + 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion new_ctr_D
lw $t0, 4($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
jal new_ctr_B                               #
lw $v0, 4($sp)      #Return self
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 8     #
jr $ra                               #

D_method7:     #
#Parametro self en stackpoiner + 60
#Parametro num@0 en stackpoiner + 56
addi $sp, $sp, -4     #Push local var x stackpointer 52
addi $sp, $sp, -4     #Push local var less@_a@0 stackpointer 48
addi $sp, $sp, -4     #Push local var less@_b@0 stackpointer 44
addi $sp, $sp, -4     #Push local var int_eq@_a@0 stackpointer 40
addi $sp, $sp, -4     #Push local var int_eq@_b@0 stackpointer 36
addi $sp, $sp, -4     #Push local var int_eq@_a@1 stackpointer 32
addi $sp, $sp, -4     #Push local var int_eq@_b@1 stackpointer 28
addi $sp, $sp, -4     #Push local var int_eq@_a@2 stackpointer 24
addi $sp, $sp, -4     #Push local var int_eq@_b@2 stackpointer 20
addi $sp, $sp, -4     #Push local var rest@_a@0 stackpointer 16
addi $sp, $sp, -4     #Push local var rest@_b@0 stackpointer 12
addi $sp, $sp, -4     #Push local var param_0_to_method7@0 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_method7@1 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion D_method7
#Eval Expression to Let x
#Get Local Var num
lw $t0, 56($sp)      #
sw $t0, 52($sp)      #
#Fin de la asignacion Let x
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion less
#Get Local Var x
lw $t0, 52($sp)      #
sw $t0, 48($sp)      #
#Resolucion del operado izquierdo de una operacion less
#Evaluando el operado derecho de una operacion less
li $s4, 0      #
lw $s6, 60($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 44($sp)      #
#Resolucion del operado derecha de una operacion less
lw $s6, 60($sp)      #Guarda self
lw $a0, 48($sp)      #Guarda el parametro 0 -> less@_a@0
lw $a1, 44($sp)      #Guarda el parametro 1 -> less@_b@0
jal __int__le__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 60($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_D_method7_0     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
li $s4, 0      #
lw $s6, 60($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 40($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
#Get Local Var x
lw $t0, 52($sp)      #
sw $t0, 36($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 60($sp)      #Guarda self
lw $a0, 40($sp)      #Guarda el parametro 0 -> int_eq@_a@0
lw $a1, 36($sp)      #Guarda el parametro 1 -> int_eq@_b@0
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 60($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_D_method7_1     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
li $s4, 1      #
lw $s6, 60($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 32($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
#Get Local Var x
lw $t0, 52($sp)      #
sw $t0, 28($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 60($sp)      #Guarda self
lw $a0, 32($sp)      #Guarda el parametro 0 -> int_eq@_a@1
lw $a1, 28($sp)      #Guarda el parametro 1 -> int_eq@_b@1
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 60($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_D_method7_2     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
li $s4, 2      #
lw $s6, 60($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 24($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
#Get Local Var x
lw $t0, 52($sp)      #
sw $t0, 20($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 60($sp)      #Guarda self
lw $a0, 24($sp)      #Guarda el parametro 0 -> int_eq@_a@2
lw $a1, 20($sp)      #Guarda el parametro 1 -> int_eq@_b@2
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 60($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_D_method7_3     #
#Else case
#StaticDispatch method7
#Evalua el parametro 0 para el CastingDispatch method7
#Evaluando el operado izquierdo de una operacion rest
#Get Local Var x
lw $t0, 52($sp)      #
sw $t0, 16($sp)      #
#Resolucion del operado izquierdo de una operacion rest
#Evaluando el operado derecho de una operacion rest
li $s4, 3      #
lw $s6, 60($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 12($sp)      #
#Resolucion del operado derecha de una operacion rest
lw $s6, 60($sp)      #Guarda self
lw $a0, 16($sp)      #Guarda el parametro 0 -> rest@_a@0
lw $a1, 12($sp)      #Guarda el parametro 1 -> rest@_b@0
jal __int__sub__                               #
sw $v0, 8($sp)      #
#Fin del paramentro 0 al CastingDispatch method7
lw $t0, 60($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 12($sp)      #Lee el valor de la var param_0_to_method7@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_method7@0
lw $t0, 68($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de D
lw $t3, 52($t1)      #Buscando el metodo dinamico para la funcion method7
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
j fin_D_method7_3                               #
then_D_method7_3:
#Then case
li $s4, 0      #
lw $s6, 60($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
lw $s6, 60($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __bool__new__                               #
move $s4, $v0      #
fin_D_method7_3:
#Fin de un If
j fin_D_method7_2                               #
then_D_method7_2:
#Then case
li $s4, 0      #
lw $s6, 60($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
lw $s6, 60($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __bool__new__                               #
move $s4, $v0      #
fin_D_method7_2:
#Fin de un If
j fin_D_method7_1                               #
then_D_method7_1:
#Then case
li $s4, 1      #
lw $s6, 60($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
lw $s6, 60($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __bool__new__                               #
move $s4, $v0      #
fin_D_method7_1:
#Fin de un If
j fin_D_method7_0                               #
then_D_method7_0:
#Then case
#StaticDispatch method7
#Evalua el parametro 0 para el CastingDispatch method7
#Evaluando la expression de una operacion unaria
#Get Local Var x
lw $t0, 52($sp)      #
move $s4, $t0      #
#FIN expression de una operacion unaria
lw $s6, 60($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__complement__                               #
sw $v0, 4($sp)      #
#Fin del paramentro 0 al CastingDispatch method7
lw $t0, 60($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_method7@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_method7@1
lw $t0, 68($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de D
lw $t3, 52($t1)      #Buscando el metodo dinamico para la funcion method7
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
fin_D_method7_0:
#Fin de un If
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 64     #
jr $ra                               #

new_ctr_C:     #
#Parametro self en stackpoiner + 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion new_ctr_C
lw $t0, 4($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
jal new_ctr_B                               #
lw $v0, 4($sp)      #Return self
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 8     #
jr $ra                               #

C_method5:     #
#Parametro self en stackpoiner + 40
#Parametro num@0 en stackpoiner + 36
addi $sp, $sp, -4     #Push local var x stackpointer 32
addi $sp, $sp, -4     #Push local var factor@_a@0 stackpointer 28
addi $sp, $sp, -4     #Push local var factor@_b@0 stackpointer 24
addi $sp, $sp, -4     #Push local var factor@_a@1 stackpointer 20
addi $sp, $sp, -4     #Push local var factor@_b@1 stackpointer 16
addi $sp, $sp, -4     #Push local var new_E@0 stackpointer 12
addi $sp, $sp, -4     #Push local var instance_dynamic_to_set_var@0 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_set_var@0 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion C_method5
li $s4, 0      #
lw $s6, 40($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 32($sp)      #
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Asignando un nuevo valor a la variable x
#Evaluando el operado izquierdo de una operacion factor
#Evaluando el operado izquierdo de una operacion factor
#Get Local Var num
lw $t0, 36($sp)      #
sw $t0, 20($sp)      #
#Resolucion del operado izquierdo de una operacion factor
#Evaluando el operado derecho de una operacion factor
#Get Local Var num
lw $t0, 36($sp)      #
sw $t0, 16($sp)      #
#Resolucion del operado derecha de una operacion factor
lw $s6, 40($sp)      #Guarda self
lw $a0, 20($sp)      #Guarda el parametro 0 -> factor@_a@1
lw $a1, 16($sp)      #Guarda el parametro 1 -> factor@_b@1
jal __int__mul__                               #
sw $v0, 28($sp)      #
#Resolucion del operado izquierdo de una operacion factor
#Evaluando el operado derecho de una operacion factor
#Get Local Var num
lw $t0, 36($sp)      #
sw $t0, 24($sp)      #
#Resolucion del operado derecha de una operacion factor
lw $s6, 40($sp)      #Guarda self
lw $a0, 28($sp)      #Guarda el parametro 0 -> factor@_a@0
lw $a1, 24($sp)      #Guarda el parametro 1 -> factor@_b@0
jal __int__mul__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 32($sp)      #
lw $t0, 32($sp)      #
move $s4, $t0      #
#Inicio del paso 1 de una sequencia Block
#Evalua la Expresion para el DinamicDispatch set_var
#Creando instancia de tipo E
#Allocate a una class E
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 12($sp)      #Guardando en la variable local new_E@0 puntero de la instancia de la clase E
#Assignacion de la insformacion de tipo a la instancia
la $t0, E      #
move $s4, $t0      #
lw $t0, 12($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 12($sp)      #Lee el valor de la var new_E@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_E@0
jal new_ctr_E                               #
sw $v0, 8($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch set_var
#Evalua el parametro 0 para el CastingDispatch set_var
#Get Local Var x
lw $t0, 32($sp)      #
sw $t0, 4($sp)      #
#Fin del paramentro 0 al CastingDispatch set_var
lw $t0, 8($sp)      #Lee el valor de la var instance_dynamic_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_set_var@0
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_set_var@0
lw $t0, 16($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de E
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion set_var
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 44     #
jr $ra                               #

B_method5:     #
#Parametro self en stackpoiner + 32
#Parametro num@0 en stackpoiner + 28
addi $sp, $sp, -4     #Push local var x stackpointer 24
addi $sp, $sp, -4     #Push local var factor@_a@0 stackpointer 20
addi $sp, $sp, -4     #Push local var factor@_b@0 stackpointer 16
addi $sp, $sp, -4     #Push local var new_E@0 stackpointer 12
addi $sp, $sp, -4     #Push local var instance_dynamic_to_set_var@0 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_set_var@0 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion B_method5
li $s4, 0      #
lw $s6, 32($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 24($sp)      #
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Asignando un nuevo valor a la variable x
#Evaluando el operado izquierdo de una operacion factor
#Get Local Var num
lw $t0, 28($sp)      #
sw $t0, 20($sp)      #
#Resolucion del operado izquierdo de una operacion factor
#Evaluando el operado derecho de una operacion factor
#Get Local Var num
lw $t0, 28($sp)      #
sw $t0, 16($sp)      #
#Resolucion del operado derecha de una operacion factor
lw $s6, 32($sp)      #Guarda self
lw $a0, 20($sp)      #Guarda el parametro 0 -> factor@_a@0
lw $a1, 16($sp)      #Guarda el parametro 1 -> factor@_b@0
jal __int__mul__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 24($sp)      #
lw $t0, 24($sp)      #
move $s4, $t0      #
#Inicio del paso 1 de una sequencia Block
#Evalua la Expresion para el DinamicDispatch set_var
#Creando instancia de tipo E
#Allocate a una class E
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 12($sp)      #Guardando en la variable local new_E@0 puntero de la instancia de la clase E
#Assignacion de la insformacion de tipo a la instancia
la $t0, E      #
move $s4, $t0      #
lw $t0, 12($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 12($sp)      #Lee el valor de la var new_E@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_E@0
jal new_ctr_E                               #
sw $v0, 8($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch set_var
#Evalua el parametro 0 para el CastingDispatch set_var
#Get Local Var x
lw $t0, 24($sp)      #
sw $t0, 4($sp)      #
#Fin del paramentro 0 al CastingDispatch set_var
lw $t0, 8($sp)      #Lee el valor de la var instance_dynamic_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_set_var@0
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_set_var@0
lw $t0, 16($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de E
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion set_var
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 36     #
jr $ra                               #

A_method5:     #
#Parametro self en stackpoiner + 52
#Parametro num@0 en stackpoiner + 48
addi $sp, $sp, -4     #Push local var x stackpointer 44
addi $sp, $sp, -4     #Push local var y stackpointer 40
addi $sp, $sp, -4     #Push local var factor@_a@0 stackpointer 36
addi $sp, $sp, -4     #Push local var factor@_b@0 stackpointer 32
addi $sp, $sp, -4     #Push local var sum@_a@0 stackpointer 28
addi $sp, $sp, -4     #Push local var sum@_b@0 stackpointer 24
addi $sp, $sp, -4     #Push local var leq@_a@0 stackpointer 20
addi $sp, $sp, -4     #Push local var leq@_b@0 stackpointer 16
addi $sp, $sp, -4     #Push local var new_E@0 stackpointer 12
addi $sp, $sp, -4     #Push local var instance_dynamic_to_set_var@0 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_set_var@0 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion A_method5
#Eval Expression to Let x
li $s4, 1      #
lw $s6, 52($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 44($sp)      #
#Fin de la asignacion Let x
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Eval Expression to Let y
li $s4, 1      #
lw $s6, 52($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 40($sp)      #
#Fin de la asignacion Let y
#Inicio de un While
j while_cond_0                               #
while_back_0:
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Asignando un nuevo valor a la variable x
#Evaluando el operado izquierdo de una operacion factor
#Get Local Var x
lw $t0, 44($sp)      #
sw $t0, 36($sp)      #
#Resolucion del operado izquierdo de una operacion factor
#Evaluando el operado derecho de una operacion factor
#Get Local Var y
lw $t0, 40($sp)      #
sw $t0, 32($sp)      #
#Resolucion del operado derecha de una operacion factor
lw $s6, 52($sp)      #Guarda self
lw $a0, 36($sp)      #Guarda el parametro 0 -> factor@_a@0
lw $a1, 32($sp)      #Guarda el parametro 1 -> factor@_b@0
jal __int__mul__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 44($sp)      #
lw $t0, 44($sp)      #
move $s4, $t0      #
#Inicio del paso 1 de una sequencia Block
#Asignando un nuevo valor a la variable y
#Evaluando el operado izquierdo de una operacion sum
#Get Local Var y
lw $t0, 40($sp)      #
sw $t0, 28($sp)      #
#Resolucion del operado izquierdo de una operacion sum
#Evaluando el operado derecho de una operacion sum
li $s4, 1      #
lw $s6, 52($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 24($sp)      #
#Resolucion del operado derecha de una operacion sum
lw $s6, 52($sp)      #Guarda self
lw $a0, 28($sp)      #Guarda el parametro 0 -> sum@_a@0
lw $a1, 24($sp)      #Guarda el parametro 1 -> sum@_b@0
jal __int__sum__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 40($sp)      #
lw $t0, 40($sp)      #
move $s4, $t0      #
#Fin del cuerpo e inicio de la condicion de un While
while_cond_0:
#Evaluando el operado izquierdo de una operacion leq
#Get Local Var y
lw $t0, 40($sp)      #
sw $t0, 20($sp)      #
#Resolucion del operado izquierdo de una operacion leq
#Evaluando el operado derecho de una operacion leq
#Get Local Var num
lw $t0, 48($sp)      #
sw $t0, 16($sp)      #
#Resolucion del operado derecha de una operacion leq
lw $s6, 52($sp)      #Guarda self
lw $a0, 20($sp)      #Guarda el parametro 0 -> leq@_a@0
lw $a1, 16($sp)      #Guarda el parametro 1 -> leq@_b@0
jal __int__leq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 52($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, while_back_0     #
#Fin de la condicion de un While
lw $t0, 52($sp)      #
move $s4, $t0      #
#Inicio del paso 1 de una sequencia Block
#Evalua la Expresion para el DinamicDispatch set_var
#Creando instancia de tipo E
#Allocate a una class E
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 12($sp)      #Guardando en la variable local new_E@0 puntero de la instancia de la clase E
#Assignacion de la insformacion de tipo a la instancia
la $t0, E      #
move $s4, $t0      #
lw $t0, 12($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 12($sp)      #Lee el valor de la var new_E@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_E@0
jal new_ctr_E                               #
sw $v0, 8($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch set_var
#Evalua el parametro 0 para el CastingDispatch set_var
#Get Local Var x
lw $t0, 44($sp)      #
sw $t0, 4($sp)      #
#Fin del paramentro 0 al CastingDispatch set_var
lw $t0, 8($sp)      #Lee el valor de la var instance_dynamic_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_set_var@0
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_set_var@0
lw $t0, 16($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de E
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion set_var
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 56     #
jr $ra                               #

Main_get_int:     #
#Parametro self en stackpoiner + 24
addi $sp, $sp, -4     #Push local var z stackpointer 20
addi $sp, $sp, -4     #Push local var new_A2I@0 stackpointer 16
addi $sp, $sp, -4     #Push local var s stackpointer 12
addi $sp, $sp, -4     #Push local var instance_dynamic_to_a2i@0 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_a2i@0 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion Main_get_int
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Eval Expression to Let z
#Creando instancia de tipo A2I
#Allocate a una class A2I
#atributo type_name en puntero + 0
li $a0, 4      #
li $v0, 9      #
syscall
sw $v0, 16($sp)      #Guardando en la variable local new_A2I@0 puntero de la instancia de la clase A2I
#Assignacion de la insformacion de tipo a la instancia
la $t0, A2I      #
move $s4, $t0      #
lw $t0, 16($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 16($sp)      #Lee el valor de la var new_A2I@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_A2I@0
jal new_ctr_A2I                               #
sw $v0, 20($sp)      #Asigna el resultado de la funcion
#Fin de la asignacion Let z
#Eval Expression to Let s
#StaticDispatch prompt
lw $t0, 24($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 28($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 44($t1)      #Buscando el metodo dinamico para la funcion prompt
jal $t3                               #
sw $v0, 12($sp)      #Asigna el resultado de la funcion
#Fin de la asignacion Let s
#Evalua la Expresion para el DinamicDispatch a2i
#Get Local Var z
lw $t0, 20($sp)      #
sw $t0, 8($sp)      #
#Fin de la exprecion previa al DinamicDispatch a2i
#Evalua el parametro 0 para el CastingDispatch a2i
#Get Local Var s
lw $t0, 12($sp)      #
sw $t0, 4($sp)      #
#Fin del paramentro 0 al CastingDispatch a2i
lw $t0, 8($sp)      #Lee el valor de la var instance_dynamic_to_a2i@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_a2i@0
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_a2i@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_a2i@0
lw $t0, 16($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A2I
lw $t3, 32($t1)      #Buscando el metodo dinamico para la funcion a2i
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 28     #
jr $ra                               #

A_set_var:     #
#Parametro self en stackpoiner + 8
#Parametro num@0 en stackpoiner + 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion A_set_var
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Asignando un nuevo valor a la variable var
#Get Local Var num
lw $t0, 4($sp)      #
move $s4, $t0      #
lw $t0, 8($sp)      #Instancia de la clase A
move $t1, $s4      #Guarda el valor que se le asignara a la propieded var
sw $t1, 4($t0)      #Setea la propiedad var con el valor de _
lw $t0, 8($sp)      #Instancia de la clase A
lw $t1, 4($t0)      #Lee la propiedad var
move $s4, $t1      #Guarda el valor de la propiedad var en la variable local _
#Inicio del paso 1 de una sequencia Block
#Get Local Var self
lw $t0, 8($sp)      #
move $s4, $t0      #
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 12     #
jr $ra                               #

A_method4:     #
#Parametro self en stackpoiner + 68
#Parametro num1@0 en stackpoiner + 64
#Parametro num2@0 en stackpoiner + 60
addi $sp, $sp, -4     #Push local var less@_a@0 stackpointer 56
addi $sp, $sp, -4     #Push local var less@_b@0 stackpointer 52
addi $sp, $sp, -4     #Push local var x stackpointer 48
addi $sp, $sp, -4     #Push local var rest@_a@0 stackpointer 44
addi $sp, $sp, -4     #Push local var rest@_b@0 stackpointer 40
addi $sp, $sp, -4     #Push local var new_D@0 stackpointer 36
addi $sp, $sp, -4     #Push local var instance_dynamic_to_set_var@0 stackpointer 32
addi $sp, $sp, -4     #Push local var param_0_to_set_var@0 stackpointer 28
addi $sp, $sp, -4     #Push local var x stackpointer 24
addi $sp, $sp, -4     #Push local var rest@_a@1 stackpointer 20
addi $sp, $sp, -4     #Push local var rest@_b@1 stackpointer 16
addi $sp, $sp, -4     #Push local var new_D@1 stackpointer 12
addi $sp, $sp, -4     #Push local var instance_dynamic_to_set_var@1 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_set_var@1 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion A_method4
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion less
#Get Local Var num2
lw $t0, 60($sp)      #
sw $t0, 56($sp)      #
#Resolucion del operado izquierdo de una operacion less
#Evaluando el operado derecho de una operacion less
#Get Local Var num1
lw $t0, 64($sp)      #
sw $t0, 52($sp)      #
#Resolucion del operado derecha de una operacion less
lw $s6, 68($sp)      #Guarda self
lw $a0, 56($sp)      #Guarda el parametro 0 -> less@_a@0
lw $a1, 52($sp)      #Guarda el parametro 1 -> less@_b@0
jal __int__le__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 68($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A_method4_0     #
#Else case
li $s4, 0      #
lw $s6, 68($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 48($sp)      #
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Asignando un nuevo valor a la variable x
#Evaluando el operado izquierdo de una operacion rest
#Get Local Var num2
lw $t0, 60($sp)      #
sw $t0, 44($sp)      #
#Resolucion del operado izquierdo de una operacion rest
#Evaluando el operado derecho de una operacion rest
#Get Local Var num1
lw $t0, 64($sp)      #
sw $t0, 40($sp)      #
#Resolucion del operado derecha de una operacion rest
lw $s6, 68($sp)      #Guarda self
lw $a0, 44($sp)      #Guarda el parametro 0 -> rest@_a@0
lw $a1, 40($sp)      #Guarda el parametro 1 -> rest@_b@0
jal __int__sub__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 48($sp)      #
lw $t0, 48($sp)      #
move $s4, $t0      #
#Inicio del paso 1 de una sequencia Block
#Evalua la Expresion para el DinamicDispatch set_var
#Creando instancia de tipo D
#Allocate a una class D
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 36($sp)      #Guardando en la variable local new_D@0 puntero de la instancia de la clase D
#Assignacion de la insformacion de tipo a la instancia
la $t0, D      #
move $s4, $t0      #
lw $t0, 36($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 36($sp)      #Lee el valor de la var new_D@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_D@0
jal new_ctr_D                               #
sw $v0, 32($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch set_var
#Evalua el parametro 0 para el CastingDispatch set_var
#Get Local Var x
lw $t0, 48($sp)      #
sw $t0, 28($sp)      #
#Fin del paramentro 0 al CastingDispatch set_var
lw $t0, 32($sp)      #Lee el valor de la var instance_dynamic_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_set_var@0
lw $t0, 32($sp)      #Lee el valor de la var param_0_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_set_var@0
lw $t0, 40($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de D
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion set_var
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
j fin_A_method4_0                               #
then_A_method4_0:
#Then case
li $s4, 0      #
lw $s6, 68($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 48($sp)      #
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Asignando un nuevo valor a la variable x
#Evaluando el operado izquierdo de una operacion rest
#Get Local Var num1
lw $t0, 64($sp)      #
sw $t0, 20($sp)      #
#Resolucion del operado izquierdo de una operacion rest
#Evaluando el operado derecho de una operacion rest
#Get Local Var num2
lw $t0, 60($sp)      #
sw $t0, 16($sp)      #
#Resolucion del operado derecha de una operacion rest
lw $s6, 68($sp)      #Guarda self
lw $a0, 20($sp)      #Guarda el parametro 0 -> rest@_a@1
lw $a1, 16($sp)      #Guarda el parametro 1 -> rest@_b@1
jal __int__sub__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 48($sp)      #
lw $t0, 48($sp)      #
move $s4, $t0      #
#Inicio del paso 1 de una sequencia Block
#Evalua la Expresion para el DinamicDispatch set_var
#Creando instancia de tipo D
#Allocate a una class D
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 12($sp)      #Guardando en la variable local new_D@1 puntero de la instancia de la clase D
#Assignacion de la insformacion de tipo a la instancia
la $t0, D      #
move $s4, $t0      #
lw $t0, 12($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 12($sp)      #Lee el valor de la var new_D@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_D@1
jal new_ctr_D                               #
sw $v0, 8($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch set_var
#Evalua el parametro 0 para el CastingDispatch set_var
#Get Local Var x
lw $t0, 48($sp)      #
sw $t0, 4($sp)      #
#Fin del paramentro 0 al CastingDispatch set_var
lw $t0, 8($sp)      #Lee el valor de la var instance_dynamic_to_set_var@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_set_var@1
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_set_var@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_set_var@1
lw $t0, 16($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de D
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion set_var
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
fin_A_method4_0:
#Fin de un If
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 72     #
jr $ra                               #

A_method3:     #
#Parametro self en stackpoiner + 24
#Parametro num@0 en stackpoiner + 20
addi $sp, $sp, -4     #Push local var x stackpointer 16
addi $sp, $sp, -4     #Push local var new_C@0 stackpointer 12
addi $sp, $sp, -4     #Push local var instance_dynamic_to_set_var@0 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_set_var@0 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion A_method3
li $s4, 0      #
lw $s6, 24($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 16($sp)      #
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Asignando un nuevo valor a la variable x
#Evaluando la expression de una operacion unaria
#Get Local Var num
lw $t0, 20($sp)      #
move $s4, $t0      #
#FIN expression de una operacion unaria
lw $s6, 24($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__complement__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 16($sp)      #
lw $t0, 16($sp)      #
move $s4, $t0      #
#Inicio del paso 1 de una sequencia Block
#Evalua la Expresion para el DinamicDispatch set_var
#Creando instancia de tipo C
#Allocate a una class C
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 12($sp)      #Guardando en la variable local new_C@0 puntero de la instancia de la clase C
#Assignacion de la insformacion de tipo a la instancia
la $t0, C      #
move $s4, $t0      #
lw $t0, 12($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 12($sp)      #Lee el valor de la var new_C@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_C@0
jal new_ctr_C                               #
sw $v0, 8($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch set_var
#Evalua el parametro 0 para el CastingDispatch set_var
#Get Local Var x
lw $t0, 16($sp)      #
sw $t0, 4($sp)      #
#Fin del paramentro 0 al CastingDispatch set_var
lw $t0, 8($sp)      #Lee el valor de la var instance_dynamic_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_set_var@0
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_set_var@0
lw $t0, 16($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de C
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion set_var
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 28     #
jr $ra                               #

Object_abort:     #
#Parametro self en stackpoiner + 0
addi $sp, $sp, -4     #Push local var $ra stackpointer -4
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion Object_abort
lw $s6, 4($sp)      #Guarda self
la $a0, _______error______      #
jal __str__new__                               #
move $a0, $v0      #
jal __str__print__                               #Print "Abort called from class "
lw $t0, ($s6)      #Read type property of self
lw $a0, ($t0)      #Read type_name of self type
jal __str__new__                               #
move $a0, $v0      #
jal __str__print__                               #Type class"
la $a0, _______endline_______      #
jal __str__new__                               #
move $a0, $v0      #
jal __str__print__                               #Print "endline"
li $v0, 10      #
syscall

new_ctr_B:     #
#Parametro self en stackpoiner + 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion new_ctr_B
lw $t0, 4($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
jal new_ctr_A                               #
lw $v0, 4($sp)      #Return self
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 8     #
jr $ra                               #

A_method2:     #
#Parametro self en stackpoiner + 36
#Parametro num1@0 en stackpoiner + 32
#Parametro num2@0 en stackpoiner + 28
addi $sp, $sp, -4     #Push local var x stackpointer 24
addi $sp, $sp, -4     #Push local var sum@_a@0 stackpointer 20
addi $sp, $sp, -4     #Push local var sum@_b@0 stackpointer 16
addi $sp, $sp, -4     #Push local var new_B@0 stackpointer 12
addi $sp, $sp, -4     #Push local var instance_dynamic_to_set_var@0 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_set_var@0 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion A_method2
li $s4, 0      #
lw $s6, 36($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 24($sp)      #
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Asignando un nuevo valor a la variable x
#Evaluando el operado izquierdo de una operacion sum
#Get Local Var num1
lw $t0, 32($sp)      #
sw $t0, 20($sp)      #
#Resolucion del operado izquierdo de una operacion sum
#Evaluando el operado derecho de una operacion sum
#Get Local Var num2
lw $t0, 28($sp)      #
sw $t0, 16($sp)      #
#Resolucion del operado derecha de una operacion sum
lw $s6, 36($sp)      #Guarda self
lw $a0, 20($sp)      #Guarda el parametro 0 -> sum@_a@0
lw $a1, 16($sp)      #Guarda el parametro 1 -> sum@_b@0
jal __int__sum__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 24($sp)      #
lw $t0, 24($sp)      #
move $s4, $t0      #
#Inicio del paso 1 de una sequencia Block
#Evalua la Expresion para el DinamicDispatch set_var
#Creando instancia de tipo B
#Allocate a una class B
#atributo type_name en puntero + 0
#atributo var en puntero + 4
li $a0, 8      #
li $v0, 9      #
syscall
sw $v0, 12($sp)      #Guardando en la variable local new_B@0 puntero de la instancia de la clase B
#Assignacion de la insformacion de tipo a la instancia
la $t0, B      #
move $s4, $t0      #
lw $t0, 12($sp)      #Instancia de la clase 
move $t1, $s4      #Guarda el valor que se le asignara a la propieded type_name
sw $t1, 0($t0)      #Setea la propiedad type_name con el valor de _
lw $t0, 12($sp)      #Lee el valor de la var new_B@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con new_B@0
jal new_ctr_B                               #
sw $v0, 8($sp)      #Asigna el resultado de la funcion
#Fin de la exprecion previa al DinamicDispatch set_var
#Evalua el parametro 0 para el CastingDispatch set_var
#Get Local Var x
lw $t0, 24($sp)      #
sw $t0, 4($sp)      #
#Fin del paramentro 0 al CastingDispatch set_var
lw $t0, 8($sp)      #Lee el valor de la var instance_dynamic_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_set_var@0
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_set_var@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_set_var@0
lw $t0, 16($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de B
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion set_var
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 40     #
jr $ra                               #

new_ctr_Object:     #
#Parametro self en stackpoiner + 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion new_ctr_Object
lw $v0, 4($sp)      #Return self
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 8     #
jr $ra                               #

IO_in_string:     #
#Parametro self en stackpoiner + 0
addi $sp, $sp, -4     #Push local var $ra stackpointer -4
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion IO_in_string
lw $s6, 4($sp)      #Guarda self
jal __str__input__                               #
lw $ra, 0($sp)      #
addi $sp, $sp, 8     #
jr $ra                               #

String_concat:     #
#Parametro self en stackpoiner + 4
#Parametro string en stackpoiner + 0
addi $sp, $sp, -4     #Push local var $ra stackpointer -4
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion String_concat
lw $s6, 8($sp)      #Guarda self
lw $a0, 4($sp)      #Guarda el parametro 0 -> string
jal __str__concat__                               #
lw $ra, 0($sp)      #
addi $sp, $sp, 12     #
jr $ra                               #

A2I_i2c:     #
#Parametro self en stackpoiner + 88
#Parametro i@0 en stackpoiner + 84
addi $sp, $sp, -4     #Push local var int_eq@_a@0 stackpointer 80
addi $sp, $sp, -4     #Push local var int_eq@_b@0 stackpointer 76
addi $sp, $sp, -4     #Push local var int_eq@_a@1 stackpointer 72
addi $sp, $sp, -4     #Push local var int_eq@_b@1 stackpointer 68
addi $sp, $sp, -4     #Push local var int_eq@_a@2 stackpointer 64
addi $sp, $sp, -4     #Push local var int_eq@_b@2 stackpointer 60
addi $sp, $sp, -4     #Push local var int_eq@_a@3 stackpointer 56
addi $sp, $sp, -4     #Push local var int_eq@_b@3 stackpointer 52
addi $sp, $sp, -4     #Push local var int_eq@_a@4 stackpointer 48
addi $sp, $sp, -4     #Push local var int_eq@_b@4 stackpointer 44
addi $sp, $sp, -4     #Push local var int_eq@_a@5 stackpointer 40
addi $sp, $sp, -4     #Push local var int_eq@_b@5 stackpointer 36
addi $sp, $sp, -4     #Push local var int_eq@_a@6 stackpointer 32
addi $sp, $sp, -4     #Push local var int_eq@_b@6 stackpointer 28
addi $sp, $sp, -4     #Push local var int_eq@_a@7 stackpointer 24
addi $sp, $sp, -4     #Push local var int_eq@_b@7 stackpointer 20
addi $sp, $sp, -4     #Push local var int_eq@_a@8 stackpointer 16
addi $sp, $sp, -4     #Push local var int_eq@_b@8 stackpointer 12
addi $sp, $sp, -4     #Push local var int_eq@_a@9 stackpointer 8
addi $sp, $sp, -4     #Push local var int_eq@_b@9 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion A2I_i2c
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
#Get Local Var i
lw $t0, 84($sp)      #
sw $t0, 80($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
li $s4, 0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 76($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 80($sp)      #Guarda el parametro 0 -> int_eq@_a@0
lw $a1, 76($sp)      #Guarda el parametro 1 -> int_eq@_b@0
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_i2c_0     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
#Get Local Var i
lw $t0, 84($sp)      #
sw $t0, 72($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
li $s4, 1      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 68($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 72($sp)      #Guarda el parametro 0 -> int_eq@_a@1
lw $a1, 68($sp)      #Guarda el parametro 1 -> int_eq@_b@1
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_i2c_1     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
#Get Local Var i
lw $t0, 84($sp)      #
sw $t0, 64($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
li $s4, 2      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 60($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 64($sp)      #Guarda el parametro 0 -> int_eq@_a@2
lw $a1, 60($sp)      #Guarda el parametro 1 -> int_eq@_b@2
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_i2c_2     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
#Get Local Var i
lw $t0, 84($sp)      #
sw $t0, 56($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
li $s4, 3      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 52($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 56($sp)      #Guarda el parametro 0 -> int_eq@_a@3
lw $a1, 52($sp)      #Guarda el parametro 1 -> int_eq@_b@3
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_i2c_3     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
#Get Local Var i
lw $t0, 84($sp)      #
sw $t0, 48($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
li $s4, 4      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 44($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 48($sp)      #Guarda el parametro 0 -> int_eq@_a@4
lw $a1, 44($sp)      #Guarda el parametro 1 -> int_eq@_b@4
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_i2c_4     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
#Get Local Var i
lw $t0, 84($sp)      #
sw $t0, 40($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
li $s4, 5      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 36($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 40($sp)      #Guarda el parametro 0 -> int_eq@_a@5
lw $a1, 36($sp)      #Guarda el parametro 1 -> int_eq@_b@5
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_i2c_5     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
#Get Local Var i
lw $t0, 84($sp)      #
sw $t0, 32($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
li $s4, 6      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 28($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 32($sp)      #Guarda el parametro 0 -> int_eq@_a@6
lw $a1, 28($sp)      #Guarda el parametro 1 -> int_eq@_b@6
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_i2c_6     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
#Get Local Var i
lw $t0, 84($sp)      #
sw $t0, 24($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
li $s4, 7      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 20($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 24($sp)      #Guarda el parametro 0 -> int_eq@_a@7
lw $a1, 20($sp)      #Guarda el parametro 1 -> int_eq@_b@7
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_i2c_7     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
#Get Local Var i
lw $t0, 84($sp)      #
sw $t0, 16($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
li $s4, 8      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 12($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 16($sp)      #Guarda el parametro 0 -> int_eq@_a@8
lw $a1, 12($sp)      #Guarda el parametro 1 -> int_eq@_b@8
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_i2c_8     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
#Get Local Var i
lw $t0, 84($sp)      #
sw $t0, 8($sp)      #
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
li $s4, 9      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 4($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 8($sp)      #Guarda el parametro 0 -> int_eq@_a@9
lw $a1, 4($sp)      #Guarda el parametro 1 -> int_eq@_b@9
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_i2c_9     #
#Else case
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#StaticDispatch abort
lw $t0, 88($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 92($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A2I
lw $t3, 12($t1)      #Buscando el metodo dinamico para la funcion abort
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 1 de una sequencia Block
la $t0, string_10      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
move $s4, $v0      #
j fin_A2I_i2c_9                               #
then_A2I_i2c_9:
#Then case
la $t0, string_11      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
move $s4, $v0      #
fin_A2I_i2c_9:
#Fin de un If
j fin_A2I_i2c_8                               #
then_A2I_i2c_8:
#Then case
la $t0, string_12      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
move $s4, $v0      #
fin_A2I_i2c_8:
#Fin de un If
j fin_A2I_i2c_7                               #
then_A2I_i2c_7:
#Then case
la $t0, string_13      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
move $s4, $v0      #
fin_A2I_i2c_7:
#Fin de un If
j fin_A2I_i2c_6                               #
then_A2I_i2c_6:
#Then case
la $t0, string_14      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
move $s4, $v0      #
fin_A2I_i2c_6:
#Fin de un If
j fin_A2I_i2c_5                               #
then_A2I_i2c_5:
#Then case
la $t0, string_15      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
move $s4, $v0      #
fin_A2I_i2c_5:
#Fin de un If
j fin_A2I_i2c_4                               #
then_A2I_i2c_4:
#Then case
la $t0, string_16      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
move $s4, $v0      #
fin_A2I_i2c_4:
#Fin de un If
j fin_A2I_i2c_3                               #
then_A2I_i2c_3:
#Then case
la $t0, string_17      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
move $s4, $v0      #
fin_A2I_i2c_3:
#Fin de un If
j fin_A2I_i2c_2                               #
then_A2I_i2c_2:
#Then case
la $t0, string_18      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
move $s4, $v0      #
fin_A2I_i2c_2:
#Fin de un If
j fin_A2I_i2c_1                               #
then_A2I_i2c_1:
#Then case
la $t0, string_19      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
move $s4, $v0      #
fin_A2I_i2c_1:
#Fin de un If
j fin_A2I_i2c_0                               #
then_A2I_i2c_0:
#Then case
la $t0, string_20      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
move $s4, $v0      #
fin_A2I_i2c_0:
#Fin de un If
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 92     #
jr $ra                               #

Main_prompt:     #
#Parametro self en stackpoiner + 12
addi $sp, $sp, -4     #Push local var param_0_to_out_string@0 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_out_string@1 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion Main_prompt
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_44      #
move $s4, $t0      #
lw $s6, 12($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 8($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 12($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 12($sp)      #Lee el valor de la var param_0_to_out_string@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@0
lw $t0, 20($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 1 de una sequencia Block
#StaticDispatch out_string
#Evalua el parametro 0 para el CastingDispatch out_string
la $t0, string_45      #
move $s4, $t0      #
lw $s6, 12($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 4($sp)      #
#Fin del paramentro 0 al CastingDispatch out_string
lw $t0, 12($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_out_string@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_out_string@1
lw $t0, 20($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion out_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 2 de una sequencia Block
#StaticDispatch in_string
lw $t0, 12($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 16($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de Main
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion in_string
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 16     #
jr $ra                               #

A2I_a2i:     #
#Parametro self en stackpoiner + 120
#Parametro s@0 en stackpoiner + 116
addi $sp, $sp, -4     #Push local var int_eq@_a@0 stackpointer 112
addi $sp, $sp, -4     #Push local var int_eq@_b@0 stackpointer 108
addi $sp, $sp, -4     #Push local var instance_dynamic_to_length@0 stackpointer 104
addi $sp, $sp, -4     #Push local var str_eq@_a@0 stackpointer 100
addi $sp, $sp, -4     #Push local var str_eq@_b@0 stackpointer 96
addi $sp, $sp, -4     #Push local var instance_dynamic_to_substr@0 stackpointer 92
addi $sp, $sp, -4     #Push local var param_0_to_substr@0 stackpointer 88
addi $sp, $sp, -4     #Push local var param_1_to_substr@0 stackpointer 84
addi $sp, $sp, -4     #Push local var str_eq@_a@1 stackpointer 80
addi $sp, $sp, -4     #Push local var str_eq@_b@1 stackpointer 76
addi $sp, $sp, -4     #Push local var instance_dynamic_to_substr@1 stackpointer 72
addi $sp, $sp, -4     #Push local var param_0_to_substr@1 stackpointer 68
addi $sp, $sp, -4     #Push local var param_1_to_substr@1 stackpointer 64
addi $sp, $sp, -4     #Push local var param_0_to_a2i_aux@0 stackpointer 60
addi $sp, $sp, -4     #Push local var instance_dynamic_to_substr@2 stackpointer 56
addi $sp, $sp, -4     #Push local var param_0_to_substr@2 stackpointer 52
addi $sp, $sp, -4     #Push local var rest@_a@0 stackpointer 48
addi $sp, $sp, -4     #Push local var rest@_b@0 stackpointer 44
addi $sp, $sp, -4     #Push local var instance_dynamic_to_length@1 stackpointer 40
addi $sp, $sp, -4     #Push local var param_1_to_substr@2 stackpointer 36
addi $sp, $sp, -4     #Push local var param_0_to_a2i_aux@1 stackpointer 32
addi $sp, $sp, -4     #Push local var instance_dynamic_to_substr@3 stackpointer 28
addi $sp, $sp, -4     #Push local var param_0_to_substr@3 stackpointer 24
addi $sp, $sp, -4     #Push local var rest@_a@1 stackpointer 20
addi $sp, $sp, -4     #Push local var rest@_b@1 stackpointer 16
addi $sp, $sp, -4     #Push local var instance_dynamic_to_length@2 stackpointer 12
addi $sp, $sp, -4     #Push local var param_1_to_substr@3 stackpointer 8
addi $sp, $sp, -4     #Push local var param_0_to_a2i_aux@2 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion A2I_a2i
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion int_eq
#Evalua la Expresion para el DinamicDispatch length
#Get Local Var s
#Fin de la exprecion previa al DinamicDispatch length
lw $t0, 116($sp)      #Lee el valor de la var s@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con s@0
lw $t0, 120($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de String
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion length
jal $t3                               #
sw $v0, 112($sp)      #Asigna el resultado de la funcion
#Resolucion del operado izquierdo de una operacion int_eq
#Evaluando el operado derecho de una operacion int_eq
li $s4, 0      #
lw $s6, 120($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 108($sp)      #
#Resolucion del operado derecha de una operacion int_eq
lw $s6, 120($sp)      #Guarda self
lw $a0, 112($sp)      #Guarda el parametro 0 -> int_eq@_a@0
lw $a1, 108($sp)      #Guarda el parametro 1 -> int_eq@_b@0
jal __int__eq__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 120($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_a2i_0     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Evalua la Expresion para el DinamicDispatch substr
#Get Local Var s
lw $t0, 116($sp)      #
sw $t0, 92($sp)      #
#Fin de la exprecion previa al DinamicDispatch substr
#Evalua el parametro 0 para el CastingDispatch substr
li $s4, 0      #
lw $s6, 120($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 88($sp)      #
#Fin del paramentro 0 al CastingDispatch substr
#Evalua el parametro 1 para el CastingDispatch substr
li $s4, 1      #
lw $s6, 120($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 84($sp)      #
#Fin del paramentro 1 al CastingDispatch substr
lw $t0, 92($sp)      #Lee el valor de la var instance_dynamic_to_substr@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_substr@0
lw $t0, 92($sp)      #Lee el valor de la var param_0_to_substr@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_substr@0
lw $t0, 92($sp)      #Lee el valor de la var param_1_to_substr@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_1_to_substr@0
lw $t0, 104($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de String
lw $t3, 32($t1)      #Buscando el metodo dinamico para la funcion substr
jal $t3                               #
sw $v0, 100($sp)      #Asigna el resultado de la funcion
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_21      #
move $s4, $t0      #
lw $s6, 120($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 96($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 120($sp)      #Guarda self
lw $a0, 100($sp)      #Guarda el parametro 0 -> str_eq@_a@0
lw $a1, 96($sp)      #Guarda el parametro 1 -> str_eq@_b@0
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 120($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_a2i_1     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Evalua la Expresion para el DinamicDispatch substr
#Get Local Var s
lw $t0, 116($sp)      #
sw $t0, 72($sp)      #
#Fin de la exprecion previa al DinamicDispatch substr
#Evalua el parametro 0 para el CastingDispatch substr
li $s4, 0      #
lw $s6, 120($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 68($sp)      #
#Fin del paramentro 0 al CastingDispatch substr
#Evalua el parametro 1 para el CastingDispatch substr
li $s4, 1      #
lw $s6, 120($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 64($sp)      #
#Fin del paramentro 1 al CastingDispatch substr
lw $t0, 72($sp)      #Lee el valor de la var instance_dynamic_to_substr@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_substr@1
lw $t0, 72($sp)      #Lee el valor de la var param_0_to_substr@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_substr@1
lw $t0, 72($sp)      #Lee el valor de la var param_1_to_substr@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_1_to_substr@1
lw $t0, 84($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de String
lw $t3, 32($t1)      #Buscando el metodo dinamico para la funcion substr
jal $t3                               #
sw $v0, 80($sp)      #Asigna el resultado de la funcion
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_22      #
move $s4, $t0      #
lw $s6, 120($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 76($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 120($sp)      #Guarda self
lw $a0, 80($sp)      #Guarda el parametro 0 -> str_eq@_a@1
lw $a1, 76($sp)      #Guarda el parametro 1 -> str_eq@_b@1
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 120($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_a2i_2     #
#Else case
#StaticDispatch a2i_aux
#Evalua el parametro 0 para el CastingDispatch a2i_aux
#Get Local Var s
lw $t0, 116($sp)      #
sw $t0, 60($sp)      #
#Fin del paramentro 0 al CastingDispatch a2i_aux
lw $t0, 120($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 64($sp)      #Lee el valor de la var param_0_to_a2i_aux@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_a2i_aux@0
lw $t0, 128($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A2I
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion a2i_aux
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
j fin_A2I_a2i_2                               #
then_A2I_a2i_2:
#Then case
#StaticDispatch a2i_aux
#Evalua el parametro 0 para el CastingDispatch a2i_aux
#Evalua la Expresion para el DinamicDispatch substr
#Get Local Var s
lw $t0, 116($sp)      #
sw $t0, 56($sp)      #
#Fin de la exprecion previa al DinamicDispatch substr
#Evalua el parametro 0 para el CastingDispatch substr
li $s4, 1      #
lw $s6, 120($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 52($sp)      #
#Fin del paramentro 0 al CastingDispatch substr
#Evalua el parametro 1 para el CastingDispatch substr
#Evaluando el operado izquierdo de una operacion rest
#Evalua la Expresion para el DinamicDispatch length
#Get Local Var s
#Fin de la exprecion previa al DinamicDispatch length
lw $t0, 116($sp)      #Lee el valor de la var s@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con s@0
lw $t0, 120($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de String
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion length
jal $t3                               #
sw $v0, 48($sp)      #Asigna el resultado de la funcion
#Resolucion del operado izquierdo de una operacion rest
#Evaluando el operado derecho de una operacion rest
li $s4, 1      #
lw $s6, 120($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 44($sp)      #
#Resolucion del operado derecha de una operacion rest
lw $s6, 120($sp)      #Guarda self
lw $a0, 48($sp)      #Guarda el parametro 0 -> rest@_a@0
lw $a1, 44($sp)      #Guarda el parametro 1 -> rest@_b@0
jal __int__sub__                               #
sw $v0, 36($sp)      #
#Fin del paramentro 1 al CastingDispatch substr
lw $t0, 56($sp)      #Lee el valor de la var instance_dynamic_to_substr@2
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_substr@2
lw $t0, 56($sp)      #Lee el valor de la var param_0_to_substr@2
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_substr@2
lw $t0, 44($sp)      #Lee el valor de la var param_1_to_substr@2
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_1_to_substr@2
lw $t0, 68($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de String
lw $t3, 32($t1)      #Buscando el metodo dinamico para la funcion substr
jal $t3                               #
sw $v0, 32($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch a2i_aux
lw $t0, 120($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 36($sp)      #Lee el valor de la var param_0_to_a2i_aux@1
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_a2i_aux@1
lw $t0, 128($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A2I
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion a2i_aux
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
fin_A2I_a2i_2:
#Fin de un If
j fin_A2I_a2i_1                               #
then_A2I_a2i_1:
#Then case
#Evaluando la expression de una operacion unaria
#StaticDispatch a2i_aux
#Evalua el parametro 0 para el CastingDispatch a2i_aux
#Evalua la Expresion para el DinamicDispatch substr
#Get Local Var s
lw $t0, 116($sp)      #
sw $t0, 28($sp)      #
#Fin de la exprecion previa al DinamicDispatch substr
#Evalua el parametro 0 para el CastingDispatch substr
li $s4, 1      #
lw $s6, 120($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 24($sp)      #
#Fin del paramentro 0 al CastingDispatch substr
#Evalua el parametro 1 para el CastingDispatch substr
#Evaluando el operado izquierdo de una operacion rest
#Evalua la Expresion para el DinamicDispatch length
#Get Local Var s
#Fin de la exprecion previa al DinamicDispatch length
lw $t0, 116($sp)      #Lee el valor de la var s@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con s@0
lw $t0, 120($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de String
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion length
jal $t3                               #
sw $v0, 20($sp)      #Asigna el resultado de la funcion
#Resolucion del operado izquierdo de una operacion rest
#Evaluando el operado derecho de una operacion rest
li $s4, 1      #
lw $s6, 120($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 16($sp)      #
#Resolucion del operado derecha de una operacion rest
lw $s6, 120($sp)      #Guarda self
lw $a0, 20($sp)      #Guarda el parametro 0 -> rest@_a@1
lw $a1, 16($sp)      #Guarda el parametro 1 -> rest@_b@1
jal __int__sub__                               #
sw $v0, 8($sp)      #
#Fin del paramentro 1 al CastingDispatch substr
lw $t0, 28($sp)      #Lee el valor de la var instance_dynamic_to_substr@3
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_substr@3
lw $t0, 28($sp)      #Lee el valor de la var param_0_to_substr@3
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_substr@3
lw $t0, 16($sp)      #Lee el valor de la var param_1_to_substr@3
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_1_to_substr@3
lw $t0, 40($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de String
lw $t3, 32($t1)      #Buscando el metodo dinamico para la funcion substr
jal $t3                               #
sw $v0, 4($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch a2i_aux
lw $t0, 120($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 8($sp)      #Lee el valor de la var param_0_to_a2i_aux@2
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_a2i_aux@2
lw $t0, 128($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A2I
lw $t3, 36($t1)      #Buscando el metodo dinamico para la funcion a2i_aux
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#FIN expression de una operacion unaria
lw $s6, 120($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__complement__                               #
move $s4, $v0      #
fin_A2I_a2i_1:
#Fin de un If
j fin_A2I_a2i_0                               #
then_A2I_a2i_0:
#Then case
li $s4, 0      #
lw $s6, 120($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
fin_A2I_a2i_0:
#Fin de un If
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 124     #
jr $ra                               #

A2I_a2i_aux:     #
#Parametro self en stackpoiner + 72
#Parametro s@0 en stackpoiner + 68
addi $sp, $sp, -4     #Push local var int stackpointer 64
addi $sp, $sp, -4     #Push local var j stackpointer 60
addi $sp, $sp, -4     #Push local var instance_dynamic_to_length@0 stackpointer 56
addi $sp, $sp, -4     #Push local var i stackpointer 52
addi $sp, $sp, -4     #Push local var sum@_a@0 stackpointer 48
addi $sp, $sp, -4     #Push local var sum@_b@0 stackpointer 44
addi $sp, $sp, -4     #Push local var factor@_a@0 stackpointer 40
addi $sp, $sp, -4     #Push local var factor@_b@0 stackpointer 36
addi $sp, $sp, -4     #Push local var instance_dynamic_to_substr@0 stackpointer 32
addi $sp, $sp, -4     #Push local var param_0_to_substr@0 stackpointer 28
addi $sp, $sp, -4     #Push local var param_1_to_substr@0 stackpointer 24
addi $sp, $sp, -4     #Push local var param_0_to_c2i@0 stackpointer 20
addi $sp, $sp, -4     #Push local var sum@_a@1 stackpointer 16
addi $sp, $sp, -4     #Push local var sum@_b@1 stackpointer 12
addi $sp, $sp, -4     #Push local var less@_a@0 stackpointer 8
addi $sp, $sp, -4     #Push local var less@_b@0 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion A2I_a2i_aux
#Eval Expression to Let int
li $s4, 0      #
lw $s6, 72($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 64($sp)      #
#Fin de la asignacion Let int
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Eval Expression to Let j
#Evalua la Expresion para el DinamicDispatch length
#Get Local Var s
#Fin de la exprecion previa al DinamicDispatch length
lw $t0, 68($sp)      #Lee el valor de la var s@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con s@0
lw $t0, 72($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de String
lw $t3, 28($t1)      #Buscando el metodo dinamico para la funcion length
jal $t3                               #
sw $v0, 60($sp)      #Asigna el resultado de la funcion
#Fin de la asignacion Let j
#Eval Expression to Let i
li $s4, 0      #
lw $s6, 72($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 52($sp)      #
#Fin de la asignacion Let i
#Inicio de un While
j while_cond_1                               #
while_back_1:
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#Asignando un nuevo valor a la variable int
#Evaluando el operado izquierdo de una operacion sum
#Evaluando el operado izquierdo de una operacion factor
#Get Local Var int
lw $t0, 64($sp)      #
sw $t0, 40($sp)      #
#Resolucion del operado izquierdo de una operacion factor
#Evaluando el operado derecho de una operacion factor
li $s4, 10      #
lw $s6, 72($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 36($sp)      #
#Resolucion del operado derecha de una operacion factor
lw $s6, 72($sp)      #Guarda self
lw $a0, 40($sp)      #Guarda el parametro 0 -> factor@_a@0
lw $a1, 36($sp)      #Guarda el parametro 1 -> factor@_b@0
jal __int__mul__                               #
sw $v0, 48($sp)      #
#Resolucion del operado izquierdo de una operacion sum
#Evaluando el operado derecho de una operacion sum
#StaticDispatch c2i
#Evalua el parametro 0 para el CastingDispatch c2i
#Evalua la Expresion para el DinamicDispatch substr
#Get Local Var s
lw $t0, 68($sp)      #
sw $t0, 32($sp)      #
#Fin de la exprecion previa al DinamicDispatch substr
#Evalua el parametro 0 para el CastingDispatch substr
#Get Local Var i
lw $t0, 52($sp)      #
sw $t0, 28($sp)      #
#Fin del paramentro 0 al CastingDispatch substr
#Evalua el parametro 1 para el CastingDispatch substr
li $s4, 1      #
lw $s6, 72($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 24($sp)      #
#Fin del paramentro 1 al CastingDispatch substr
lw $t0, 32($sp)      #Lee el valor de la var instance_dynamic_to_substr@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con instance_dynamic_to_substr@0
lw $t0, 32($sp)      #Lee el valor de la var param_0_to_substr@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_substr@0
lw $t0, 32($sp)      #Lee el valor de la var param_1_to_substr@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_1_to_substr@0
lw $t0, 44($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de String
lw $t3, 32($t1)      #Buscando el metodo dinamico para la funcion substr
jal $t3                               #
sw $v0, 20($sp)      #Asigna el resultado de la funcion
#Fin del paramentro 0 al CastingDispatch c2i
lw $t0, 72($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 24($sp)      #Lee el valor de la var param_0_to_c2i@0
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con param_0_to_c2i@0
lw $t0, 80($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A2I
lw $t3, 24($t1)      #Buscando el metodo dinamico para la funcion c2i
jal $t3                               #
sw $v0, 44($sp)      #Asigna el resultado de la funcion
#Resolucion del operado derecha de una operacion sum
lw $s6, 72($sp)      #Guarda self
lw $a0, 48($sp)      #Guarda el parametro 0 -> sum@_a@0
lw $a1, 44($sp)      #Guarda el parametro 1 -> sum@_b@0
jal __int__sum__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 64($sp)      #
lw $t0, 64($sp)      #
move $s4, $t0      #
#Inicio del paso 1 de una sequencia Block
#Asignando un nuevo valor a la variable i
#Evaluando el operado izquierdo de una operacion sum
#Get Local Var i
lw $t0, 52($sp)      #
sw $t0, 16($sp)      #
#Resolucion del operado izquierdo de una operacion sum
#Evaluando el operado derecho de una operacion sum
li $s4, 1      #
lw $s6, 72($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
sw $v0, 12($sp)      #
#Resolucion del operado derecha de una operacion sum
lw $s6, 72($sp)      #Guarda self
lw $a0, 16($sp)      #Guarda el parametro 0 -> sum@_a@1
lw $a1, 12($sp)      #Guarda el parametro 1 -> sum@_b@1
jal __int__sum__                               #
move $s4, $v0      #
move $t0, $s4      #
sw $t0, 52($sp)      #
lw $t0, 52($sp)      #
move $s4, $t0      #
#Fin del cuerpo e inicio de la condicion de un While
while_cond_1:
#Evaluando el operado izquierdo de una operacion less
#Get Local Var i
lw $t0, 52($sp)      #
sw $t0, 8($sp)      #
#Resolucion del operado izquierdo de una operacion less
#Evaluando el operado derecho de una operacion less
#Get Local Var j
lw $t0, 60($sp)      #
sw $t0, 4($sp)      #
#Resolucion del operado derecha de una operacion less
lw $s6, 72($sp)      #Guarda self
lw $a0, 8($sp)      #Guarda el parametro 0 -> less@_a@0
lw $a1, 4($sp)      #Guarda el parametro 1 -> less@_b@0
jal __int__le__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 72($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, while_back_1     #
#Fin de la condicion de un While
lw $t0, 72($sp)      #
move $s4, $t0      #
#Inicio del paso 1 de una sequencia Block
#Get Local Var int
lw $t0, 64($sp)      #
move $s4, $t0      #
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 76     #
jr $ra                               #

String_length:     #
#Parametro self en stackpoiner + 0
addi $sp, $sp, -4     #Push local var $ra stackpointer -4
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion String_length
lw $s6, 4($sp)      #Guarda self
jal __str__length__                               #
lw $ra, 0($sp)      #
addi $sp, $sp, 8     #
jr $ra                               #

String_substr:     #
#Parametro self en stackpoiner + 8
#Parametro index en stackpoiner + 4
#Parametro count en stackpoiner + 0
addi $sp, $sp, -4     #Push local var $ra stackpointer -4
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion String_substr
lw $s6, 12($sp)      #Guarda self
lw $a0, 8($sp)      #Guarda el parametro 0 -> index
lw $a1, 4($sp)      #Guarda el parametro 1 -> count
jal __str__substr__                               #
lw $ra, 0($sp)      #
addi $sp, $sp, 16     #
jr $ra                               #

A2I_c2i:     #
#Parametro self en stackpoiner + 88
#Parametro char@0 en stackpoiner + 84
addi $sp, $sp, -4     #Push local var str_eq@_a@0 stackpointer 80
addi $sp, $sp, -4     #Push local var str_eq@_b@0 stackpointer 76
addi $sp, $sp, -4     #Push local var str_eq@_a@1 stackpointer 72
addi $sp, $sp, -4     #Push local var str_eq@_b@1 stackpointer 68
addi $sp, $sp, -4     #Push local var str_eq@_a@2 stackpointer 64
addi $sp, $sp, -4     #Push local var str_eq@_b@2 stackpointer 60
addi $sp, $sp, -4     #Push local var str_eq@_a@3 stackpointer 56
addi $sp, $sp, -4     #Push local var str_eq@_b@3 stackpointer 52
addi $sp, $sp, -4     #Push local var str_eq@_a@4 stackpointer 48
addi $sp, $sp, -4     #Push local var str_eq@_b@4 stackpointer 44
addi $sp, $sp, -4     #Push local var str_eq@_a@5 stackpointer 40
addi $sp, $sp, -4     #Push local var str_eq@_b@5 stackpointer 36
addi $sp, $sp, -4     #Push local var str_eq@_a@6 stackpointer 32
addi $sp, $sp, -4     #Push local var str_eq@_b@6 stackpointer 28
addi $sp, $sp, -4     #Push local var str_eq@_a@7 stackpointer 24
addi $sp, $sp, -4     #Push local var str_eq@_b@7 stackpointer 20
addi $sp, $sp, -4     #Push local var str_eq@_a@8 stackpointer 16
addi $sp, $sp, -4     #Push local var str_eq@_b@8 stackpointer 12
addi $sp, $sp, -4     #Push local var str_eq@_a@9 stackpointer 8
addi $sp, $sp, -4     #Push local var str_eq@_b@9 stackpointer 4
addi $sp, $sp, -4     #Push local var $ra stackpointer 0
sw $ra, 0($sp)      #Agrega $ra a la pila para salvar el punto de retorno de la funcion A2I_c2i
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Local Var char
lw $t0, 84($sp)      #
sw $t0, 80($sp)      #
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_0      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 76($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 80($sp)      #Guarda el parametro 0 -> str_eq@_a@0
lw $a1, 76($sp)      #Guarda el parametro 1 -> str_eq@_b@0
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_c2i_0     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Local Var char
lw $t0, 84($sp)      #
sw $t0, 72($sp)      #
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_1      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 68($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 72($sp)      #Guarda el parametro 0 -> str_eq@_a@1
lw $a1, 68($sp)      #Guarda el parametro 1 -> str_eq@_b@1
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_c2i_1     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Local Var char
lw $t0, 84($sp)      #
sw $t0, 64($sp)      #
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_2      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 60($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 64($sp)      #Guarda el parametro 0 -> str_eq@_a@2
lw $a1, 60($sp)      #Guarda el parametro 1 -> str_eq@_b@2
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_c2i_2     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Local Var char
lw $t0, 84($sp)      #
sw $t0, 56($sp)      #
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_3      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 52($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 56($sp)      #Guarda el parametro 0 -> str_eq@_a@3
lw $a1, 52($sp)      #Guarda el parametro 1 -> str_eq@_b@3
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_c2i_3     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Local Var char
lw $t0, 84($sp)      #
sw $t0, 48($sp)      #
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_4      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 44($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 48($sp)      #Guarda el parametro 0 -> str_eq@_a@4
lw $a1, 44($sp)      #Guarda el parametro 1 -> str_eq@_b@4
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_c2i_4     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Local Var char
lw $t0, 84($sp)      #
sw $t0, 40($sp)      #
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_5      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 36($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 40($sp)      #Guarda el parametro 0 -> str_eq@_a@5
lw $a1, 36($sp)      #Guarda el parametro 1 -> str_eq@_b@5
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_c2i_5     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Local Var char
lw $t0, 84($sp)      #
sw $t0, 32($sp)      #
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_6      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 28($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 32($sp)      #Guarda el parametro 0 -> str_eq@_a@6
lw $a1, 28($sp)      #Guarda el parametro 1 -> str_eq@_b@6
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_c2i_6     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Local Var char
lw $t0, 84($sp)      #
sw $t0, 24($sp)      #
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_7      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 20($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 24($sp)      #Guarda el parametro 0 -> str_eq@_a@7
lw $a1, 20($sp)      #Guarda el parametro 1 -> str_eq@_b@7
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_c2i_7     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Local Var char
lw $t0, 84($sp)      #
sw $t0, 16($sp)      #
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_8      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 12($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 16($sp)      #Guarda el parametro 0 -> str_eq@_a@8
lw $a1, 12($sp)      #Guarda el parametro 1 -> str_eq@_b@8
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_c2i_8     #
#Else case
#Evalua la condicion de un If
#Evaluando el operado izquierdo de una operacion str_eq
#Get Local Var char
lw $t0, 84($sp)      #
sw $t0, 8($sp)      #
#Resolucion del operado izquierdo de una operacion str_eq
#Evaluando el operado derecho de una operacion str_eq
la $t0, string_9      #
move $s4, $t0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __str__new__                               #
sw $v0, 4($sp)      #
#Resolucion del operado derecha de una operacion str_eq
lw $s6, 88($sp)      #Guarda self
lw $a0, 8($sp)      #Guarda el parametro 0 -> str_eq@_a@9
lw $a1, 4($sp)      #Guarda el parametro 1 -> str_eq@_b@9
jal __str__cmp__                               #
move $s4, $v0      #
move $a0, $v0      #
lw $s6, 88($sp)      #Guarda self
jal __bool__new__                               #
move $s4, $v0      #
#Fin de la evaluacion de la condicion de un IF
#Check Condition And Try Jump
move $t0, $s4      #Guarda el parametro 0 -> _
lw $t1, 4($t0)      #Lee la propiedad **value** del bool
li $t0, 1      #Carga un 1 para comparar
beq $t0, $t1, then_A2I_c2i_9     #
#Else case
#Inicio de una secuencia Block
#Inicio del paso 0 de una sequencia Block
#StaticDispatch abort
lw $t0, 88($sp)      #Lee el valor de la var self
addi $sp, $sp, -4     #
sw $t0, 0($sp)      #Push a la pila con self
lw $t0, 92($sp)      #
lw $t1, 0($t0)      #Leyendo el tipo dinamico de la instancia que hereda de A2I
lw $t3, 12($t1)      #Buscando el metodo dinamico para la funcion abort
jal $t3                               #
move $s4, $v0      #Asigna el resultado de la funcion
#Inicio del paso 1 de una sequencia Block
li $s4, 0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
j fin_A2I_c2i_9                               #
then_A2I_c2i_9:
#Then case
li $s4, 9      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
fin_A2I_c2i_9:
#Fin de un If
j fin_A2I_c2i_8                               #
then_A2I_c2i_8:
#Then case
li $s4, 8      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
fin_A2I_c2i_8:
#Fin de un If
j fin_A2I_c2i_7                               #
then_A2I_c2i_7:
#Then case
li $s4, 7      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
fin_A2I_c2i_7:
#Fin de un If
j fin_A2I_c2i_6                               #
then_A2I_c2i_6:
#Then case
li $s4, 6      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
fin_A2I_c2i_6:
#Fin de un If
j fin_A2I_c2i_5                               #
then_A2I_c2i_5:
#Then case
li $s4, 5      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
fin_A2I_c2i_5:
#Fin de un If
j fin_A2I_c2i_4                               #
then_A2I_c2i_4:
#Then case
li $s4, 4      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
fin_A2I_c2i_4:
#Fin de un If
j fin_A2I_c2i_3                               #
then_A2I_c2i_3:
#Then case
li $s4, 3      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
fin_A2I_c2i_3:
#Fin de un If
j fin_A2I_c2i_2                               #
then_A2I_c2i_2:
#Then case
li $s4, 2      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
fin_A2I_c2i_2:
#Fin de un If
j fin_A2I_c2i_1                               #
then_A2I_c2i_1:
#Then case
li $s4, 1      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
fin_A2I_c2i_1:
#Fin de un If
j fin_A2I_c2i_0                               #
then_A2I_c2i_0:
#Then case
li $s4, 0      #
lw $s6, 88($sp)      #Guarda self
move $a0, $s4      #Guarda el parametro 0 -> _
jal __int__new__                               #
move $s4, $v0      #
fin_A2I_c2i_0:
#Fin de un If
move $v0, $s4      #Return _
lw $ra, 0($sp)      #Lee $ra de la pila para retornar a la funcion anterior
addi $sp, $sp, 92     #
jr $ra                               #

new_ctr_Bool:     #Esta funcion no se invoca en la ejecucion del programa

new_ctr_Int:     #Esta funcion no se invoca en la ejecucion del programa

new_ctr_String:     #Esta funcion no se invoca en la ejecucion del programa

new_ctr_SELF_TYPE:     #Esta funcion no se invoca en la ejecucion del programa

IO_in_int:     #Esta funcion no se invoca en la ejecucion del programa

IO_out_int:     #Esta funcion no se invoca en la ejecucion del programa

Object_copy:     #Esta funcion no se invoca en la ejecucion del programa

Object_type_name:     #Esta funcion no se invoca en la ejecucion del programa

###########################################################################region
#########################################################################################################
___fin___:
li		$v0, 10		# system call #4 - print string
syscall				# execute

#########################################################################################################

__int__new__:
# En $s6 self
# En $a0 el valor del entero	
# Return $v0 la instancia del nuevo int

move $t2, $a0  #Salva el valor del entero  

#Allocate a una class Int
#atributo type_name en puntero + 0
#atributo value en puntero + 4
li $a0, 8
li $v0, 9
syscall  #en $v0 la instancia del nuevo Int

la $t0, Int     #Carga la direccion de memoria de la definicion de tipo Int
sw $t0, ($v0)   #Guarda en la pocision cero de la instancia la direccion de la definicion del tipo
sw $t2, 4($v0)  #Guarda en la pocicion 4 de la instancia el valor del la propiedad **value** 

# No modifica la pila 
jr $ra # Esta funcion no tiene saltos internos y en $v0 esta la instancia del nuevo Int

##########################################################################################################
__int__print__:
# En $s6 **self**
# En $a0 la direccion del **Int** a pintar 	
# Return $v0 **self**

lw $t0, 4($a0)  #Lee la propiedad **value**

li $v0, 1
move $a0, $t0  #Pinta el valor la propiedad **value** del int
syscall

move $v0, $s6  #Guarda en $v0 **self** para retornar 
# No modifica la pila 
jr $ra # Esta funcion no tiene saltos internos y en $v0 esta self

##########################################################################################################
__int__input__:
# En $s6 **self**
# Return $v0 la instancia del nuevo **Int**

li $v0, 5   #Lee un entero por la consola 
syscall     #Guarda el entero en $v0

move $s5, $ra    #Salva $ra en $s5 para saltar a crear un Int con el valor leido
move $a0, $v0
jal __int__new__ #En $v0 la instancia del nuevo entero 

move $ra, $s5   #Reasigna $ra para salir de **input** volver a la funcion anterior 
# No modifica la pila 
jr $ra          #Esta funcion tiene saltos internos y en $v0 esta la instancia del nuevo **Int**

##########################################################################################################
__int__sum__:
# En $s6 **self**
# En $a0 la direccion del **Int** a sumando A 	
# En $a1 la direccion del **Int** a sumando B 	
# Return $v0 new **Int** con **value** A+B

lw $t0, 4($a0)      #Lee la propiedad **value** del sumando A
lw $t1, 4($a1)      #Lee la propiedad **value** del sumando B
add $a0, $t0, $t1  #$a0 =  A + B

move $s5, $ra       #Guardando $ra para saltar a crear en **Int**
jal __int__new__    #Con A+B en $a0 instancia el **Int** con el valor y devuelve en $v0

move $ra, $s5   #Reasigna $ra para salir de **sum** volver a la funcion anterior 
# No modifica la pila 
jr $ra          #Esta funcion tiene saltos internos y en $v0 esta la instancia del nuevo **Int**

##########################################################################################################
__int__sub__:
# En $s6 **self**
# En $a0 la direccion del **Int** a operador A 	
# En $a1 la direccion del **Int** a operador B 	
# Return $v0 new **Int** con **value** A-B

lw $t0, 4($a0)      #Lee la propiedad **value** del operador A
lw $t1, 4($a1)      #Lee la propiedad **value** del operador B
sub	$a0, $t0, $t1   #$a0 =  A - B

move $s5, $ra       #Guardando $ra para saltar a crear en **Int**
jal __int__new__    #Con A-B en $a0 instancia el **Int** con el valor y devuelve en $v0

move $ra, $s5   #Reasigna $ra para salir de **rest** volver a la funcion anterior 
# No modifica la pila 
jr $ra          #Esta funcion tiene saltos internos y en $v0 esta la instancia del nuevo **Int**

##########################################################################################################
__int__mul__:
# En $s6 **self**
# En $a0 la direccion del **Int** a operador A 	
# En $a1 la direccion del **Int** a operador B 	
# Return $v0 new **Int** con **value** A*B

lw $t0, 4($a0)      #Lee la propiedad **value** del operador A
lw $t1, 4($a1)      #Lee la propiedad **value** del operador B
mul	$a0, $t0, $t1   #$a0 =  A * B

move $s5, $ra       #Guardando $ra para saltar a crear en **Int**
jal __int__new__    #Con A*B en $a0 instancia el **Int** con el valor y devuelve en $v0

move $ra, $s5   #Reasigna $ra para salir de **mul** volver a la funcion anterior 
# No modifica la pila 
jr $ra          #Esta funcion tiene saltos internos y en $v0 esta la instancia del nuevo **Int**

##########################################################################################################
__int__div__:
# En $s6 **self**
# En $a0 la direccion del **Int** a operador A 	
# En $a1 la direccion del **Int** a operador B 	
# Return $v0 new **Int** con **value** A/B

lw $t0, 4($a0)      #Lee la propiedad **value** del operador A
lw $t1, 4($a1)      #Lee la propiedad **value** del operador B
div	$a0, $t0, $t1   #$a0 =  A/B

move $s5, $ra       #Guardando $ra para saltar a crear en **Int**
jal __int__new__    #Con A/B en $a0 instancia el **Int** con el valor y devuelve en $v0

move $ra, $s5   #Reasigna $ra para salir de **div** volver a la funcion anterior 
# No modifica la pila 
jr $ra          #Esta funcion tiene saltos internos y en $v0 esta la instancia del nuevo **Int**

##########################################################################################################
__int__le__:
# En $s6 **self**
# En $a0 la direccion del **Int** a operador A 	
# En $a1 la direccion del **Int** a operador B 	
# Return $v0 new **Int** con **value** A-B

lw $t0, 4($a0)      #Lee la propiedad **value** del operador A
lw $t1, 4($a1)      #Lee la propiedad **value** del operador B
slt	$a0, $t0, $t1   #$a0 =  A < B

move $s5, $ra       #Guardando $ra para saltar a crear en **Int**
jal __int__new__    #Con A<B en $a0 instancia el **Int** con el valor y devuelve en $v0

move $ra, $s5   #Reasigna $ra para salir de **less** volver a la funcion anterior 
# No modifica la pila 
jr $ra          #Esta funcion tiene saltos internos y en $v0 esta la instancia del nuevo **Int**

##########################################################################################################
__int__leq__:
# En $s6 **self**
# En $a0 la direccion del **Int** a operador A 	
# En $a1 la direccion del **Int** a operador B 	
# Return $v0 new **Int** con **value** A-B

lw $t0, 4($a0)      #Lee la propiedad **value** del operador A
lw $t1, 4($a1)      #Lee la propiedad **value** del operador B
sle	$a0, $t0, $t1   #$a0 =  A <= B

move $s5, $ra       #Guardando $ra para saltar a crear en **Int**
jal __int__new__    #Con A<=B en $a0 instancia el **Int** con el valor y devuelve en $v0

move $ra, $s5   #Reasigna $ra para salir de **less_or_equal** volver a la funcion anterior 
# No modifica la pila 
jr $ra          #Esta funcion tiene saltos internos y en $v0 esta la instancia del nuevo **Int**

##########################################################################################################
__int__eq__:
# En $s6 **self**
# En $a0 la direccion del **Int** a operador A 	
# En $a1 la direccion del **Int** a operador B 	
# Return $v0 new **Int** con **value** A-B

lw $t0, 4($a0)      #Lee la propiedad **value** del operador A
lw $t1, 4($a1)      #Lee la propiedad **value** del operador B
seq	$a0, $t0, $t1   #$a0 =  A == B

move $s5, $ra       #Guardando $ra para saltar a crear en **Int**
jal __int__new__    #Con A==B en $a0 instancia el **Int** con el valor y devuelve en $v0

move $ra, $s5   #Reasigna $ra para salir de **equal** volver a la funcion anterior 
# No modifica la pila 
jr $ra          #Esta funcion tiene saltos internos y en $v0 esta la instancia del nuevo **Int**

##########################################################################################################
__int__complement__:
# En $s6 **self**
# En $a0 la direccion del **Int** a operador A 	
# Return $v0 new **Int** con **value** ~A

lw $t0, 4($a0)      #Lee la propiedad **value** del operador A
li $t1, 4294967295  # guarda 2^31 + 1
xor $a0, $t1, $t0   
add $a0, $a0, 1     

move $s5, $ra       #Guardando $ra para saltar a crear en **Int**
jal __int__new__    #Con ~A en $a0 instancia el **Int** con el valor y devuelve en $v0

move $ra, $s5   #Reasigna $ra para salir de **complement** volver a la funcion anterior 
# No modifica la pila 
jr $ra          #Esta funcion tiene saltos internos y en $v0 esta la instancia del nuevo **Int**

##########################################################################################################
__int__neg__:
# En $s6 **self**
# En $a0 la direccion del **Int** a operador A 	
# Return $v0 new **Int** con **value** !A

lw $t0, 4($a0)      #Lee la propiedad **value** del operador A
addi $a0, $t0, -1   #$a0 =  A - 1 => if A == 0 then $a0 = -1 else $a0 = 0
mul  $a0, $a0, -1   #$a0 = -$a0   => if $a0 == 0 then $a0 = 0 else 1

move $s5, $ra       #Guardando $ra para saltar a crear en **Int**
jal __int__new__    #Con A+B en $a0 instancia el **Int** con el valor y devuelve en $v0

move $ra, $s5   #Reasigna $ra para salir de **rest** volver a la funcion anterior 
# No modifica la pila 
jr $ra          #Esta funcion tiene saltos internos y en $v0 esta la instancia del nuevo **Int**

##########################################################################################################
__int__clone__:
# En $s6 self



#region
##########################################################################################
__bool__new__:
# En $s6 self
# En $a0 instancia de Int para convertir 	
# Return $v0 la instancia del nuevo Bool

lw $t0, 4($a0) # Guardando el valor la propiedad de **value**

li $t1, 1
beq $t0, $t1, __bool__ok_value__  #Comparando el valor con 1
li $t1, 0
beq $t0, $t1, __bool__ok_value__  #Comparando el valor con 0

# Si el valor no es ni cero ni uno cierra el programa 
li		$v0, 4		# system call #4 - print string
la		$a0, Bool_Name
syscall				# execute
li		$v0, 1		# system call #4 - print string
move	$a0, $t0
syscall				# execute
li		$v0, 10		# system call #4 - print string
syscall				# execute

__bool__ok_value__:
la $t0, Bool     #Carga la direccion de memoria de la definicion de tipo Bool
sw $t0, ($a0)    #Guarda en la pocision cero de la instancia la direccion de la definicion del tipo

move $v0, $a0
# No modifica la pila 
jr $ra # Esta funcion no tiene saltos internos y en $v0 esta la instancia del nuevo Bool

##########################################################################################################
__bool__if_go_to__:
# En $s6 self
# En $a0 instancia de Bool a evaluar 
# En $a1 direccion a la que saltar  
# Return $v0 la instancia del nuevo Bool

lw $t0, 4($a0)  #Guarda el valor de la propiedad **value** del Bool
li $t1, 1       #Guarda 1 en $t0 para comparar con la propiedad **value**

beq	$t0, $t1, __go_to__	# if $t0 == $t1 then __go_to__
jr $ra          #esta funcion solo termina si el bool es false 
__go_to__:
j $a1   # La condicion se cumple salta hacia el segundo parametro

##########################################################################################################
__bool__check__type__:
# En $s6 **self**
# En $a0 direccion de memoria de la lista de ancestro de un typo 
# En $a1 identificador numerico de un tipo

li $v0, 1       # Por default devuelve 1
__check__type__loop__:
    lw $t0, ($a0)       #Lee el id de un typo 
    beq $t0, $zero, __check__type__false__
    beq $t0, $a1, __check__type__end__
    addi $a0, $a0, 4
    j __check__type__loop__

__check__type__false__: 
    li $v0, 0
__check__type__end__:
    jr $ra

#region
#############################################################################################
__str__new__:
# En $s6 self
# En $a0 el direccion de memoria que apunta a un string	
# Return $v0 la instancia del nuevo string

move $t2, $a0  #Salva la direccion de memoria  

#Allocate a una class String
#atributo type_name en puntero + 0
#atributo value en puntero + 4
li $a0, 8
li $v0, 9
syscall  #en $v0 la instancia del nuevo String

la $t0, String     #Carga la direccion de memoria de la definicion de tipo Int
sw $t0, ($v0)   #Guarda en la pocision cero de la instancia la direccion de la definicion del tipo
sw $t2, 4($v0)  #Guarda en la pocicion 4 de la instancia el valor del la propiedad **value** 

# No modifica la pila 
jr $ra # Esta funcion no tiene saltos internos y en $v0 esta la instancia del nuevo Int

##########################################################################################################
__str__print__:
# En $s6 **self**
# En $a0 la direccion del **String** a pintar 	
# Return $v0 **self**

lw $t0, 4($a0)  #Lee la propiedad **value**

li $v0, 4
move $a0, $t0  #Pinta el valor la propiedad **value** del String
syscall

move $v0, $s6  #Guarda en $v0 **self** para retornar 
# No modifica la pila 
jr $ra # Esta funcion no tiene saltos internos y en $v0 esta self

##########################################################################################################
__str__input__:
# En $s6 **self**
# Return $v0 la instancia del nuevo **String**

addi $sp, $sp, -4
sw $ra ($sp)   #Salva $ra en 12($sp)
addi $sp, $sp, -4
sw $s6, ($sp)    #Salva self en 8($sp)

li $a0, 1000    # reserva memoria para el string
li $v0, 9       
syscall         # En $v0 direccion de memoria del nuevo string

move $a0, $v0   # Asigan la direccion del nuevo string para llamar a la funcion de leer
li $v0, 8       # Leer un string de la consola 
li $a1 , 1000   
syscall         # En $a0 el string leido en la consola 
jal __str__new__ #En $v0 la instancia del nuevo entero 
move $a0, $v0

addi $sp, $sp, -4
sw $v0, ($sp)    #Salva el nuevo string en 4($sp)

move $s6, $v0   #cambia sefl por el nuevo string 
jal __str__length__

lw $t0, 4($v0)      #Lee la propiedad **value** del **Int** que devuelve length 

beq $t0,$zero, jline
addi $t0, $t0, -1   #Resta uno al length para eliminar el '\n'

jline:
sw $t0, 4($v0)      #Actualiza la propieded **value** del **Int** length

addi $sp, $sp, -4
sw $v0, ($sp)       #Salva el length en ($sp)

li $a0, 0
jal __int__new__    #Crea un nuevo entero con **value** 0

lw $s6, 4($sp)      #Self = al string leido en la consola 
move $a0, $v0       #index = 0 
lw $a1, ($sp)       #count = length - 1 

jal __str__substr__ #En $v0 el substring sin '\n'

lw $s6, 8($sp)   #Reasigna Self para salir de **input** volver a la funcion anterior 
lw $ra, 12($sp)  #Reasigna $ra para salir de **input** volver a la funcion anterior
addi $sp, $sp, 16 #Limpia la pila 
jr $ra          #Devuelve en $v0 el subsstring leido por la consola 

##########################################################################################################
__str__length__:
# En $s6 **self**
# Return $v0 la instancia del nuevo **Int**

li $t0 , 0       # len result
lw $t2 , 4($s6)  # Leer la propiedad value a self

loop_len:
lb  $t3, ($t2)  # Guarda la primara letra
beq $t3, $zero, end_len  
add $t0, $t0, 1 # Suma al contador 
add $t2, $t2, 1  # Mueve el punteron del string en 1 
j loop_len

end_len:
move $a0, $t0
move $s5, $ra
jal __int__new__
move $ra, $s5
jr $ra

###########################################################################################################
__str__substr__:
# En $s6 **self**
# En $a0 **Int** el indece en el que inicia el sub
# En $a1 **Int** cantidad de caracteres que tiene el sub

lw $t0, 4($s6)  # Lee la propiedad value de **sefl**
lw $t1, 4($a0)  # Lee la propiedad value del **Int** indice 
lw $t2, 4($a1)  # Lee la propiedad value del **Int** length 

li $t3, 0        # Contador para iterar el string en busqueda de indice  
li $t4, 1        # Contador para iterar el string hasta llegar al length

addi $t5, $t2, 1
move $a0, $t5      # reserva memoria para el string
li $v0,9
syscall           # En $v0 la direccion de memoria del nuevo string
move $t5, $v0    

beq $t2, $zero, end_sub_string

find_index:
    beq	 $t3, $t1, find_length	# si el contador es el indice comiensa a crear el sub
    add	 $t0, $t0, 1		    # mueve el puntero del string de self
    add	 $t3, $t3, 1	        # mueve el contador 
    j find_index

find_length:
    lb	 $t6, ($t0)			# Lee la primera letra del string self  
    sb	 $t6, ($t5)         # guarda la primera letra del string self en el nuevo string
    beq	 $t2, $t4, end_sub_string	# si el contador del tamao es igual a j end
    add	 $t5, $t5, 1		# Mueve el puntero del nuevo string 
    add	 $t0, $t0, 1		# Mueve el puntero del string self
    add	 $t4, $t4, 1	    # Contador de tamao += 1 
    j find_length
    
end_sub_string:
    add	 $t5, $t5, 1		# Mueve el puntero del nuevo string 
    sb	 $zero, ($t5)         # guarda la primera letra del string self en el nuevo string

    addi $sp, $sp, -4
    sw $ra, ($sp)   # Guarda en la pila $ra

    move $a0, $v0       # Pasa como parametros la direccion de memoria del string
    jal __str__new__    # En $v0 la instancia del nuevos string

    lw $ra, ($sp)       # Reasigna $ra para volver al la funcion anterior 
    addi $sp, $sp, 4    #  Limpia la pila 
    jr $ra              # Return instancia del substring en $v0

############################################################################################################
__str__concat__:
# En $s6 **self**
# En #a0 instancia de otro string

addi $sp, $sp, -4
sw $s6, ($sp)       #Salva **self**
addi $sp, $sp, -4
sw $a0, ($sp)       #Salva el string que se paso como parametro 
addi $sp, $sp, -4
sw $ra, ($sp)       #Salva $ra para saber a donde retornar 

jal __str__length__
addi $sp, $sp, -4
lw $t0, 4($v0)      #Lee el valor de la propiedad **value**
sw $t0, ($sp)       #Salva el valor del primer length 

lw $t0, 8($sp)
move $s6, $t0       #Cambia self por el otro string
jal __str__length__
lw $t0, ($sp)       #Lee el lenght del string self
lw $t1, 4($v0)      #Lee el valor de la pripiedad value del resultado de la funcion length 
add $t0, $t0, $t1   # Suma los length de ambos string

add $t0, $t0, 1 
move $a0, $t0
li $v0, 9
syscall             # Reserva espacion para un string de tamao length1 + length2
#En $v0 el nuevo string 

move $t3, $v0
lw $t2, 8($sp)      #Lee el string que se paso por parametro  
lw $t1, 4($t2)      #Lee la propiedad **value** del string
lw $t2, 12($sp)     #Lee self
lw $t0, 4($t2)      #Lee la propiedad **value** de self 

loop_str1:
    lb   $t2, ($t0)       # primera letra del puntero al string self
    beq  $t2, $zero, loop_str2 
    add  $t0, $t0, 1      # mueve el puntero del string self
    sb   $t2, ($t3)       # guarda la letra en el nuevo string 
    add  $t3, $t3, 1      # mueve el puntero del nuevo string
    j loop_str1

loop_str2:
    lb   $t2, ($t1)       # primera letra del puntero al string str1
    beq  $t2, $zero, end_concat
    add  $t1, $t1, 1    # mueve el puntero del string str1
    sb   $t2, ($t3)     # guarda la letra en el nuevo string 
    add  $t3,  $t3, 1   # mueve el puntero del nuevo string
    j loop_str1

end_concat:
    move $a0, $v0
    jal __str__new__
    lw $ra, 4($sp)
    lw $s6, 12($sp)
    addi $sp, $sp, 16 #Limpia la pila
    jr $ra            # Return en $v0 la nueva instancia de self

############################################################################################################
__str__cmp__:
# En $s6 **self**
# En $a0 instancia de str1
# En $a1 instancia de str2

addi $sp, $sp -4
sw $ra, ($sp)

lw $t0, 4($a0)     #Lee la propiedad **value** de str1
lw $t1, 4($a1)     #Lee la propiedad **value** de str2
li $a0, 1       # True por default

str_cmp_loop:
    lb $t2, ($t0)   #Lee una letra de str1
    lb $t3, ($t1)   #Lee una letra de str2
    addi $t0, $t0, 1
    addi $t1, $t1, 1
    beq $t2, $zero, cmp_end_to_zero     #Se llego al fin del str1
    beq $t3, $zero, cmp_end_to_zero     #Se llego al fin del str2
    beq $t2, $t3,   str_cmp_loop        #Continua comparando si son iguales 
    j str_cmp_false

cmp_end_to_zero:
    beq $t2, $t3,  end_str_cmp         #Chequea que ambos hallan llegado al final 
    j str_cmp_false

str_cmp_false:
    li $a0, 0       #Cambia el defaul True por False 
end_str_cmp:
    jal __int__new__    #Crea un Int que luego se debe cambiar por bool
    lw $ra, ($sp)       #Lee $ra para retornar 
    addi $sp, $sp, 4    #Limpia la pila 
    jr $ra              #En $v0 un Int que hay que cambiar por Bool

